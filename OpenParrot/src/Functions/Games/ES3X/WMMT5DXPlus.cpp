#include <StdInc.h>
#include "Utility/InitFunction.h"
#include "Functions/Global.h"
#include <iostream>
#include <cstdint>
#include <fstream>
#include "MinHook.h"
#include <Utility/Hooking.Patterns.h>
#include <chrono>
#include <thread>
#ifdef _M_AMD64
#pragma optimize("", off)
#pragma comment(lib, "Ws2_32.lib")

extern LPCSTR hookPort;
uintptr_t imageBasedxplus;
static unsigned char hasp_buffer[0xD40];
static bool isFreePlay;
static bool isEventMode2P;
static bool isEventMode4P;
const char *ipaddrdxplus;
/*
// Data for IC card, Force Feedback etc OFF.
unsigned char settingData[408] = {
	0x1F, 0x8B, 0x08, 0x08, 0x53, 0x6A, 0x8B, 0x5A, 0x00, 0x03, 0x46, 0x73,
	0x65, 0x74, 0x74, 0x69, 0x6E, 0x67, 0x2E, 0x6C, 0x75, 0x61, 0x00, 0x85,
	0x93, 0x5B, 0x6F, 0x82, 0x30, 0x14, 0xC7, 0xDF, 0xF9, 0x14, 0x7E, 0x01,
	0x17, 0x11, 0xE7, 0xDC, 0xC3, 0x1E, 0x14, 0x65, 0x9A, 0x48, 0x66, 0x94,
	0x68, 0xB2, 0xB7, 0x5A, 0x8E, 0xD2, 0xD8, 0x8B, 0x29, 0xED, 0x16, 0xBF,
	0xFD, 0x5A, 0xA8, 0x50, 0xB2, 0x65, 0xF2, 0x40, 0xF8, 0xFF, 0xCE, 0x85,
	0x73, 0x69, 0xFB, 0xFD, 0xFF, 0x9F, 0xC0, 0xBE, 0x7A, 0x25, 0x28, 0x45,
	0xF8, 0xF9, 0x89, 0x6A, 0x14, 0x3C, 0x08, 0xE8, 0x07, 0x01, 0x8B, 0x11,
	0x25, 0xC7, 0x25, 0xE2, 0x39, 0x85, 0x18, 0xB8, 0x02, 0xD9, 0x7B, 0xEB,
	0x45, 0xC3, 0x97, 0xF1, 0xC4, 0x99, 0xA6, 0x18, 0x03, 0x6D, 0x2C, 0x03,
	0x47, 0x67, 0x12, 0x5D, 0xE0, 0x17, 0x4D, 0x85, 0x12, 0xB2, 0xA1, 0xCF,
	0x61, 0xE8, 0x78, 0x26, 0x34, 0x2E, 0xD6, 0x70, 0x52, 0x86, 0x0E, 0x07,
	0xA3, 0x89, 0x8F, 0xB7, 0xE4, 0x5C, 0x58, 0x1E, 0x8E, 0xA2, 0x68, 0xEC,
	0x1B, 0x32, 0x71, 0xFD, 0x0B, 0xCF, 0x84, 0x52, 0x82, 0xB5, 0x89, 0x04,
	0xE1, 0x71, 0xA1, 0x15, 0x58, 0xDF, 0x80, 0xCD, 0xF4, 0x2D, 0x46, 0x32,
	0x8F, 0x45, 0x69, 0x73, 0x46, 0x01, 0x7B, 0x47, 0x0C, 0x9C, 0x1A, 0x5A,
	0x6F, 0x6E, 0x66, 0xA3, 0x3D, 0x92, 0x68, 0x4A, 0x63, 0xA1, 0x65, 0x79,
	0x67, 0x23, 0xC3, 0x24, 0xC0, 0x86, 0xA2, 0x5B, 0x9D, 0x72, 0x83, 0x8F,
	0xAB, 0xBC, 0x6E, 0x72, 0x85, 0x6D, 0xF2, 0xED, 0xB7, 0xAF, 0xF6, 0xC0,
	0xF3, 0xFB, 0x10, 0xD2, 0xB3, 0x6F, 0x4F, 0x84, 0xC4, 0x90, 0x00, 0xE4,
	0x47, 0x84, 0x2F, 0x35, 0x3A, 0x10, 0x5E, 0x4E, 0x79, 0xBE, 0x05, 0x86,
	0xCC, 0x57, 0x9D, 0x7F, 0xF1, 0x65, 0x06, 0x96, 0x8A, 0x1C, 0x6A, 0x97,
	0x46, 0xCE, 0x49, 0x55, 0x8F, 0x8F, 0x4C, 0xA1, 0xDC, 0xD5, 0x18, 0x53,
	0x51, 0x42, 0x76, 0xBB, 0x82, 0x6B, 0xCC, 0xCA, 0x9D, 0xE6, 0x46, 0xBD,
	0x8E, 0x9D, 0x4C, 0x45, 0x47, 0x66, 0x1A, 0x7C, 0x79, 0x80, 0xBC, 0x63,
	0x2D, 0xB4, 0x2F, 0x13, 0x49, 0x7C, 0xB9, 0x43, 0xCA, 0x97, 0xF3, 0x6A,
	0x36, 0x56, 0x56, 0x2B, 0xD9, 0x20, 0x0E, 0xB4, 0x2E, 0xD5, 0x8E, 0x7B,
	0x2F, 0xAC, 0x08, 0x8D, 0x9A, 0x2A, 0x25, 0x11, 0x56, 0x2D, 0xF8, 0x38,
	0x9D, 0x28, 0xE1, 0xD0, 0x76, 0x6B, 0xD2, 0xE1, 0x8B, 0xA1, 0xE6, 0xD0,
	0xD6, 0x20, 0x23, 0x0C, 0x3E, 0x05, 0xBF, 0xB7, 0x66, 0x77, 0x6F, 0x91,
	0xF9, 0xE3, 0xDA, 0x1D, 0x14, 0xCF, 0x69, 0x69, 0x16, 0xD7, 0x04, 0x4F,
	0x5A, 0x9E, 0x12, 0xEE, 0xE7, 0xDC, 0x69, 0xC6, 0x40, 0x5A, 0x63, 0x27,
	0xA0, 0x63, 0xE9, 0x86, 0x3C, 0xBC, 0x37, 0xD5, 0x4D, 0x5B, 0x7C, 0x24,
	0x8F, 0x3D, 0x7F, 0x00, 0x10, 0x1E, 0x34, 0xD9, 0xB5, 0x03, 0x00, 0x00
};
*/
// FOR FREEPLAY
unsigned char dxpterminalPackage1_Free[79] = {
	0x01, 0x04, 0x4B, 0x00, 0x12, 0x14, 0x0A, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x00, 0x1A, 0x02, 0x5A, 0x00, 0x2A, 0x12, 0x08, 0x12, 0x12, 0x0C,
	0x32, 0x37, 0x32, 0x32, 0x31, 0x31, 0x39, 0x39, 0x30, 0x30, 0x30, 0x32,
	0x18, 0x00, 0x30, 0x03, 0x4A, 0x08, 0x08, 0x01, 0x10, 0x01, 0x18, 0x00,
	0x20, 0x00, 0x52, 0x0B, 0x08, 0x64, 0x10, 0xDE, 0x0F, 0x18, 0x05, 0x20,
	0x00, 0x28, 0x00, 0xEC, 0x72, 0x00, 0x41
};

unsigned char dxpterminalPackage2_Free[139] = {
	0x01, 0x04, 0x87, 0x00, 0x12, 0x14, 0x0A, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x00, 0x1A, 0x02, 0x5A, 0x00, 0x2A, 0x12, 0x08, 0x14, 0x12, 0x0C,
	0x32, 0x37, 0x32, 0x32, 0x31, 0x31, 0x39, 0x39, 0x30, 0x30, 0x30, 0x32,
	0x18, 0x00, 0x30, 0x03, 0x42, 0x3A, 0x08, 0x01, 0x10, 0x03, 0x18, 0x02,
	0x20, 0x02, 0x28, 0x04, 0x30, 0x01, 0x38, 0x01, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x02, 0x58, 0x60, 0x60, 0x60, 0x68, 0x60, 0x70, 0x60, 0x78, 0x60,
	0x80, 0x01, 0x60, 0x88, 0x01, 0x60, 0x90, 0x01, 0x60, 0x98, 0x01, 0x00,
	0xA0, 0x01, 0xE2, 0xBA, 0xAC, 0xD4, 0x05, 0xA8, 0x01, 0x04, 0xB0, 0x01,
	0x24, 0xB8, 0x01, 0x00, 0x4A, 0x08, 0x08, 0x01, 0x10, 0x01, 0x18, 0x00,
	0x20, 0x00, 0x52, 0x0B, 0x08, 0x64, 0x10, 0xDE, 0x0F, 0x18, 0x05, 0x20,
	0x00, 0x28, 0x00, 0x99, 0x4E, 0xC6, 0x14
};

unsigned char dxpterminalPackage3_Free[79] = {
	0x01, 0x04, 0x4B, 0x00, 0x12, 0x14, 0x0A, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x00, 0x1A, 0x02, 0x5A, 0x00, 0x2A, 0x12, 0x08, 0x19, 0x12, 0x0C,
	0x32, 0x37, 0x32, 0x32, 0x31, 0x31, 0x39, 0x39, 0x30, 0x30, 0x30, 0x32,
	0x18, 0x00, 0x30, 0x03, 0x4A, 0x08, 0x08, 0x01, 0x10, 0x01, 0x18, 0x00,
	0x20, 0x00, 0x52, 0x0B, 0x08, 0x64, 0x10, 0xDE, 0x0F, 0x18, 0x05, 0x20,
	0x00, 0x28, 0x00, 0x89, 0x93, 0x3A, 0x22
};

unsigned char dxpterminalPackage4_Free[139] = {
	0x01, 0x04, 0x87, 0x00, 0x12, 0x14, 0x0A, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x00, 0x1A, 0x02, 0x5A, 0x00, 0x2A, 0x12, 0x08, 0x2E, 0x12, 0x0C,
	0x32, 0x37, 0x32, 0x32, 0x31, 0x31, 0x39, 0x39, 0x30, 0x30, 0x30, 0x32,
	0x18, 0x00, 0x30, 0x03, 0x42, 0x3A, 0x08, 0x01, 0x10, 0x03, 0x18, 0x02,
	0x20, 0x02, 0x28, 0x04, 0x30, 0x01, 0x38, 0x01, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x02, 0x58, 0x60, 0x60, 0x60, 0x68, 0x60, 0x70, 0x60, 0x78, 0x60,
	0x80, 0x01, 0x60, 0x88, 0x01, 0x60, 0x90, 0x01, 0x60, 0x98, 0x01, 0x00,
	0xA0, 0x01, 0xF0, 0xBA, 0xAC, 0xD4, 0x05, 0xA8, 0x01, 0x04, 0xB0, 0x01,
	0x24, 0xB8, 0x01, 0x00, 0x4A, 0x08, 0x08, 0x01, 0x10, 0x01, 0x18, 0x00,
	0x20, 0x00, 0x52, 0x0B, 0x08, 0x64, 0x10, 0xDE, 0x0F, 0x18, 0x05, 0x20,
	0x00, 0x28, 0x00, 0x55, 0x42, 0x47, 0xD5
};

unsigned char dxpterminalPackage5_Free[79] = {
	0x01, 0x04, 0x4B, 0x00, 0x12, 0x14, 0x0A, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x00, 0x1A, 0x02, 0x5A, 0x00, 0x2A, 0x12, 0x08, 0x2F, 0x12, 0x0C,
	0x32, 0x37, 0x32, 0x32, 0x31, 0x31, 0x39, 0x39, 0x30, 0x30, 0x30, 0x32,
	0x18, 0x00, 0x30, 0x03, 0x4A, 0x08, 0x08, 0x01, 0x10, 0x01, 0x18, 0x00,
	0x20, 0x00, 0x52, 0x0B, 0x08, 0x64, 0x10, 0xDE, 0x0F, 0x18, 0x05, 0x20,
	0x00, 0x28, 0x00, 0x9C, 0xC9, 0xE0, 0x73
};

unsigned char dxpterminalPackage6_Free[139] = {
	0x01, 0x04, 0x87, 0x00, 0x12, 0x14, 0x0A, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x00, 0x1A, 0x02, 0x5A, 0x00, 0x2A, 0x12, 0x08, 0x6A, 0x12, 0x0C,
	0x32, 0x37, 0x32, 0x32, 0x31, 0x31, 0x39, 0x39, 0x30, 0x30, 0x30, 0x32,
	0x18, 0x00, 0x30, 0x03, 0x42, 0x3A, 0x08, 0x01, 0x10, 0x03, 0x18, 0x02,
	0x20, 0x02, 0x28, 0x04, 0x30, 0x01, 0x38, 0x01, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x02, 0x58, 0x60, 0x60, 0x60, 0x68, 0x60, 0x70, 0x60, 0x78, 0x60,
	0x80, 0x01, 0x60, 0x88, 0x01, 0x60, 0x90, 0x01, 0x60, 0x98, 0x01, 0x00,
	0xA0, 0x01, 0xF1, 0xBA, 0xAC, 0xD4, 0x05, 0xA8, 0x01, 0x04, 0xB0, 0x01,
	0x24, 0xB8, 0x01, 0x00, 0x4A, 0x08, 0x08, 0x01, 0x10, 0x01, 0x18, 0x00,
	0x20, 0x00, 0x52, 0x0B, 0x08, 0x64, 0x10, 0xDE, 0x0F, 0x18, 0x05, 0x20,
	0x00, 0x28, 0x00, 0x26, 0xB7, 0x89, 0xD0
};

// FOR COIN ENTRY!
unsigned char dxpterminalPackage1_Coin[75] = {
	0x01, 0x04, 0x47, 0x00, 0x12, 0x14, 0x0A, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x00, 0x1A, 0x00, 0x2A, 0x12, 0x08, 0x0B, 0x12, 0x0C, 0x32, 0x37,
	0x32, 0x32, 0x31, 0x31, 0x39, 0x39, 0x30, 0x30, 0x30, 0x32, 0x18, 0x00,
	0x4A, 0x08, 0x08, 0x01, 0x10, 0x01, 0x18, 0x00, 0x20, 0x00, 0x52, 0x0B,
	0x08, 0x64, 0x10, 0xDE, 0x0F, 0x18, 0x05, 0x20, 0x00, 0x28, 0x00, 0x09,
	0x06, 0x41, 0x0B
};

unsigned char dxpterminalPackage2_Coin[135] = {
	0x01, 0x04, 0x83, 0x00, 0x12, 0x14, 0x0A, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x00, 0x1A, 0x00, 0x2A, 0x12, 0x08, 0x39, 0x12, 0x0C, 0x32, 0x37,
	0x32, 0x32, 0x31, 0x31, 0x39, 0x39, 0x30, 0x30, 0x30, 0x32, 0x18, 0x00,
	0x42, 0x3A, 0x08, 0x01, 0x10, 0x03, 0x18, 0x02, 0x20, 0x02, 0x28, 0x04,
	0x30, 0x00, 0x38, 0x01, 0x40, 0x00, 0x48, 0x00, 0x50, 0x02, 0x58, 0x60,
	0x60, 0x60, 0x68, 0x60, 0x70, 0x60, 0x78, 0x60, 0x80, 0x01, 0x60, 0x88,
	0x01, 0x60, 0x90, 0x01, 0x60, 0x98, 0x01, 0x00, 0xA0, 0x01, 0xD5, 0xBE,
	0x8F, 0xD2, 0x05, 0xA8, 0x01, 0x04, 0xB0, 0x01, 0x24, 0xB8, 0x01, 0x00,
	0x4A, 0x08, 0x08, 0x01, 0x10, 0x01, 0x18, 0x00, 0x20, 0x00, 0x52, 0x0B,
	0x08, 0x64, 0x10, 0xDE, 0x0F, 0x18, 0x05, 0x20, 0x00, 0x28, 0x00, 0xF5,
	0xF1, 0x0D, 0xB2
};

unsigned char dxpterminalPackage3_Coin[75] = {
	0x01, 0x04, 0x47, 0x00, 0x12, 0x14, 0x0A, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x00, 0x1A, 0x00, 0x2A, 0x12, 0x08, 0x3A, 0x12, 0x0C, 0x32, 0x37,
	0x32, 0x32, 0x31, 0x31, 0x39, 0x39, 0x30, 0x30, 0x30, 0x32, 0x18, 0x00,
	0x4A, 0x08, 0x08, 0x01, 0x10, 0x01, 0x18, 0x00, 0x20, 0x00, 0x52, 0x0B,
	0x08, 0x64, 0x10, 0xDE, 0x0F, 0x18, 0x05, 0x20, 0x00, 0x28, 0x00, 0x22,
	0x25, 0x31, 0x0D
};

unsigned char dxpterminalPackage4_Coin[135] = {
	0x01, 0x04, 0x83, 0x00, 0x12, 0x14, 0x0A, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x00, 0x1A, 0x00, 0x2A, 0x12, 0x08, 0x57, 0x12, 0x0C, 0x32, 0x37,
	0x32, 0x32, 0x31, 0x31, 0x39, 0x39, 0x30, 0x30, 0x30, 0x32, 0x18, 0x00,
	0x42, 0x3A, 0x08, 0x01, 0x10, 0x03, 0x18, 0x02, 0x20, 0x02, 0x28, 0x04,
	0x30, 0x00, 0x38, 0x01, 0x40, 0x00, 0x48, 0x00, 0x50, 0x02, 0x58, 0x60,
	0x60, 0x60, 0x68, 0x60, 0x70, 0x60, 0x78, 0x60, 0x80, 0x01, 0x60, 0x88,
	0x01, 0x60, 0x90, 0x01, 0x60, 0x98, 0x01, 0x00, 0xA0, 0x01, 0xD6, 0xBE,
	0x8F, 0xD2, 0x05, 0xA8, 0x01, 0x04, 0xB0, 0x01, 0x24, 0xB8, 0x01, 0x00,
	0x4A, 0x08, 0x08, 0x01, 0x10, 0x01, 0x18, 0x00, 0x20, 0x00, 0x52, 0x0B,
	0x08, 0x64, 0x10, 0xDE, 0x0F, 0x18, 0x05, 0x20, 0x00, 0x28, 0x00, 0xCA,
	0x8B, 0x15, 0xCB
};

unsigned char dxpterminalPackage5_Coin[79] = {
	0x01, 0x04, 0x4B, 0x00, 0x12, 0x14, 0x0A, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x00, 0x1A, 0x02, 0x5A, 0x00, 0x2A, 0x12, 0x08, 0x58, 0x12, 0x0C,
	0x32, 0x37, 0x32, 0x32, 0x31, 0x31, 0x39, 0x39, 0x30, 0x30, 0x30, 0x32,
	0x18, 0x00, 0x30, 0x03, 0x4A, 0x08, 0x08, 0x01, 0x10, 0x01, 0x18, 0x00,
	0x20, 0x00, 0x52, 0x0B, 0x08, 0x64, 0x10, 0xDE, 0x0F, 0x18, 0x05, 0x20,
	0x00, 0x28, 0x00, 0x3E, 0xB1, 0xB7, 0x22
};

unsigned char dxpterminalPackage6_Coin[139] = {
	0x01, 0x04, 0x87, 0x00, 0x12, 0x14, 0x0A, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x00, 0x1A, 0x02, 0x5A, 0x00, 0x2A, 0x12, 0x08, 0x77, 0x12, 0x0C,
	0x32, 0x37, 0x32, 0x32, 0x31, 0x31, 0x39, 0x39, 0x30, 0x30, 0x30, 0x32,
	0x18, 0x00, 0x30, 0x03, 0x42, 0x3A, 0x08, 0x01, 0x10, 0x03, 0x18, 0x02,
	0x20, 0x02, 0x28, 0x04, 0x30, 0x00, 0x38, 0x01, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x02, 0x58, 0x60, 0x60, 0x60, 0x68, 0x60, 0x70, 0x60, 0x78, 0x60,
	0x80, 0x01, 0x60, 0x88, 0x01, 0x60, 0x90, 0x01, 0x60, 0x98, 0x01, 0x00,
	0xA0, 0x01, 0xD7, 0xBE, 0x8F, 0xD2, 0x05, 0xA8, 0x01, 0x04, 0xB0, 0x01,
	0x24, 0xB8, 0x01, 0x00, 0x4A, 0x08, 0x08, 0x01, 0x10, 0x01, 0x18, 0x00,
	0x20, 0x00, 0x52, 0x0B, 0x08, 0x64, 0x10, 0xDE, 0x0F, 0x18, 0x05, 0x20,
	0x00, 0x28, 0x00, 0xBD, 0x07, 0xCF, 0xDC
};


//Event mode 2P
unsigned char dxpterminalPackage1_Event4P[79] = {
	0x01, 0x04, 0x44, 0x00, 0x12, 0x0e, 0x0a, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x1a, 0x00, 0x2a, 0x13,
	0x08, 0xd1, 0x0b, 0x12, 0x0c, 0x32, 0x37, 0x32, 0x32, 0x31, 0x31, 0x39,
	0x39, 0x30, 0x30, 0x30, 0x32, 0x18, 0x00, 0x30, 0x00, 0x4a, 0x08, 0x08, 
	0x03, 0x10, 0x01, 0x18, 0x00, 0x20, 0x00, 0x52, 0x0b, 0x08, 0x64, 0x10,
	0xde, 0x0f, 0x18, 0x05, 0x20, 0x00, 0x28, 0x00, 0xc1, 0x96, 0xc9, 0x2e
};

unsigned char dxpterminalPackage2_Event4P[139] = {
	0x01, 0x04, 0x80, 0x00, 0x12, 0x0e, 0x0a, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x1a, 0x00, 0x2a, 0x13,
	0x08, 0xd2, 0x0b, 0x12, 0x0c, 0x32, 0x37, 0x32, 0x32, 0x31, 0x31, 0x39,
	0x39, 0x30, 0x30, 0x30, 0x32, 0x18, 0x00, 0x30, 0x00, 0x42, 0x3a, 0x08,
	0x01, 0x10, 0x03, 0x18, 0x02, 0x20, 0x02, 0x28, 0x04, 0x30, 0x01, 0x38,
	0x01, 0x40, 0x01, 0x48, 0x00, 0x50, 0x02, 0x58, 0x60, 0x60, 0x60, 0x68,
	0x60, 0x70, 0x60, 0x78, 0x60, 0x80, 0x01, 0x60, 0x88, 0x01, 0x60, 0x90,
	0x01, 0x60, 0x98, 0x01, 0x00, 0xa0, 0x01, 0xd8, 0xc3, 0xd6, 0xe1, 0x05,
	0xa8, 0x01, 0x04, 0xb0, 0x01, 0x24, 0xb8, 0x01, 0x00, 0x4a, 0x08, 0x08,
	0x03, 0x10, 0x01, 0x18, 0x00, 0x20, 0x00, 0x52, 0x0b, 0x08, 0x64, 0x10,
	0xde, 0x0f, 0x18, 0x05, 0x20, 0x00, 0x28, 0x00, 0x91, 0x74, 0xca, 0x1e

};

unsigned char dxpterminalPackage3_Event4P[79] = {
	0x01, 0x04, 0x44, 0x00, 0x12, 0x0e, 0x0a, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x1a, 0x00, 0x2a, 0x13,
	0x08, 0x8d, 0x0c, 0x12, 0x0c, 0x32, 0x37, 0x32, 0x32, 0x31, 0x31, 0x39,
	0x39, 0x30, 0x30, 0x30, 0x32, 0x18, 0x00, 0x30, 0x00, 0x4a, 0x08, 0x08,
	0x03, 0x10, 0x01, 0x18, 0x00, 0x20, 0x00, 0x52, 0x0b, 0x08, 0x64, 0x10,
	0xde, 0x0f, 0x18, 0x05, 0x20, 0x00, 0x28, 0x00, 0x86, 0xb1, 0x27, 0x9e
};

unsigned char dxpterminalPackage4_Event4P[139] = {
	0x01, 0x04, 0x80, 0x00, 0x12, 0x0e, 0x0a, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x1a, 0x00, 0x2a, 0x13,
	0x08, 0x8e, 0x0c, 0x12, 0x0c, 0x32, 0x37, 0x32, 0x32, 0x31, 0x31, 0x39,
	0x39, 0x30, 0x30, 0x30, 0x32, 0x18, 0x00, 0x30, 0x00, 0x42, 0x3a, 0x08,
	0x01, 0x10, 0x03, 0x18, 0x02, 0x20, 0x02, 0x28, 0x04, 0x30, 0x01, 0x38,
	0x01, 0x40, 0x01, 0x48, 0x00, 0x50, 0x02, 0x58, 0x60, 0x60, 0x60, 0x68,
	0x60, 0x70, 0x60, 0x78, 0x60, 0x80, 0x01, 0x60, 0x88, 0x01, 0x60, 0x90,
	0x01, 0x60, 0x98, 0x01, 0x00, 0xa0, 0x01, 0xd9, 0xc3, 0xd6, 0xe1, 0x05,
	0xa8, 0x01, 0x04, 0xb0, 0x01, 0x24, 0xb8, 0x01, 0x00, 0x4a, 0x08, 0x08,
	0x03, 0x10, 0x01, 0x18, 0x00, 0x20, 0x00, 0x52, 0x0b, 0x08, 0x64, 0x10,
	0xde, 0x0f, 0x18, 0x05, 0x20, 0x00, 0x28, 0x00, 0xc2, 0x11, 0x2a, 0x66

};

unsigned char dxpterminalPackage5_Event4P[79] = {
	0x01, 0x04, 0x44, 0x00, 0x12, 0x0e, 0x0a, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x1a, 0x00, 0x2a, 0x13,
	0x08, 0xc9, 0x0c, 0x12, 0x0c, 0x32, 0x37, 0x32, 0x32, 0x31, 0x31, 0x39,
	0x39, 0x30, 0x30, 0x30, 0x32, 0x18, 0x00, 0x30, 0x00, 0x4a, 0x08, 0x08,
	0x03, 0x10, 0x01, 0x18, 0x00, 0x20, 0x00, 0x52, 0x0b, 0x08, 0x64, 0x10,
	0xde, 0x0f, 0x18, 0x05, 0x20, 0x00, 0x28, 0x00, 0x5d, 0x49, 0x01, 0x1e
};

unsigned char dxpterminalPackage6_Event4P[139] = {
	0x01, 0x04, 0x80, 0x00, 0x12, 0x0e, 0x0a, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x1a, 0x00, 0x2a, 0x13,
	0x08, 0xca, 0x0c, 0x12, 0x0c, 0x32, 0x37, 0x32, 0x32, 0x31, 0x31, 0x39,
	0x39, 0x30, 0x30, 0x30, 0x32, 0x18, 0x00, 0x30, 0x00, 0x42, 0x3a, 0x08,
	0x01, 0x10, 0x03, 0x18, 0x02, 0x20, 0x02, 0x28, 0x04, 0x30, 0x01, 0x38,
	0x01, 0x40, 0x01, 0x48, 0x00, 0x50, 0x02, 0x58, 0x60, 0x60, 0x60, 0x68,
	0x60, 0x70, 0x60, 0x78, 0x60, 0x80, 0x01, 0x60, 0x88, 0x01, 0x60, 0x90,
	0x01, 0x60, 0x98, 0x01, 0x00, 0xa0, 0x01, 0xda, 0xc3, 0xd6, 0xe1, 0x05,
	0xa8, 0x01, 0x04, 0xb0, 0x01, 0x24, 0xb8, 0x01, 0x00, 0x4a, 0x08, 0x08,
	0x03, 0x10, 0x01, 0x18, 0x00, 0x20, 0x00, 0x52, 0x0b, 0x08, 0x64, 0x10,
	0xde, 0x0f, 0x18, 0x05, 0x20, 0x00, 0x28, 0x00, 0xd4, 0x80, 0x16, 0xc2
};


//Event mode 2P
unsigned char dxpterminalPackage1_Event2P[79] = {
	0x01, 0x04, 0x44, 0x00, 0x12, 0x0e, 0x0a, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x1a, 0x00, 0x2a, 0x13,
	0x08, 0xfe, 0x0e, 0x12, 0x0c, 0x32, 0x37, 0x32, 0x32, 0x31, 0x31, 0x39,
	0x39, 0x30, 0x30, 0x30, 0x32, 0x18, 0x00, 0x30, 0x00, 0x4a, 0x08, 0x08,
	0x03, 0x10, 0x01, 0x18, 0x00, 0x20, 0x00, 0x52, 0x0b, 0x08, 0x64, 0x10,
	0xde, 0x0f, 0x18, 0x05, 0x20, 0x00, 0x28, 0x00, 0xaf, 0xa1, 0x42, 0x3d
};

unsigned char dxpterminalPackage2_Event2P[139] = {
	0x01, 0x04, 0x80, 0x00, 0x12, 0x0e, 0x0a, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x1a, 0x00, 0x2a, 0x13,
	0x08, 0xff, 0x0e, 0x12, 0x0c, 0x32, 0x37, 0x32, 0x32, 0x31, 0x31, 0x39,
	0x39, 0x30, 0x30, 0x30, 0x32, 0x18, 0x00, 0x30, 0x00, 0x42, 0x3a, 0x08,
	0x01, 0x10, 0x03, 0x18, 0x02, 0x20, 0x02, 0x28, 0x04, 0x30, 0x01, 0x38,
	0x01, 0x40, 0x02, 0x48, 0x00, 0x50, 0x02, 0x58, 0x60, 0x60, 0x60, 0x68,
	0x60, 0x70, 0x60, 0x78, 0x60, 0x80, 0x01, 0x60, 0x88, 0x01, 0x60, 0x90,
	0x01, 0x60, 0x98, 0x01, 0x00, 0xa0, 0x01, 0xa7, 0xc2, 0xa5, 0xe1, 0x05,
	0xa8, 0x01, 0x02, 0xb0, 0x01, 0x24, 0xb8, 0x01, 0x00, 0x4a, 0x08, 0x08,
	0x03, 0x10, 0x01, 0x18, 0x00, 0x20, 0x00, 0x52, 0x0b, 0x08, 0x64, 0x10,
	0xde, 0x0f, 0x18, 0x05, 0x20, 0x00, 0x28, 0x00, 0xe8, 0x94, 0x41, 0x46

};

unsigned char dxpterminalPackage3_Event2P[79] = {
	0x01, 0x04, 0x44, 0x00, 0x12, 0x0e, 0x0a, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x1a, 0x00, 0x2a, 0x13,
	0x08, 0x80, 0x0f, 0x12, 0x0c, 0x32, 0x37, 0x32, 0x32, 0x31, 0x31, 0x39,
	0x39, 0x30, 0x30, 0x30, 0x32, 0x18, 0x00, 0x30, 0x00, 0x4a, 0x08, 0x08,
	0x03, 0x10, 0x01, 0x18, 0x00, 0x20, 0x00, 0x52, 0x0b, 0x08, 0x64, 0x10,
	0xde, 0x0f, 0x18, 0x05, 0x20, 0x00, 0x28, 0x00, 0xa3, 0x94, 0x12, 0x9b
};

unsigned char dxpterminalPackage4_Event2P[139] = {
	0x01, 0x04, 0x80, 0x00, 0x12, 0x0e, 0x0a, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x1a, 0x00, 0x2a, 0x13,
	0x08, 0x8d, 0x0f, 0x12, 0x0c, 0x32, 0x37, 0x32, 0x32, 0x31, 0x31, 0x39,
	0x39, 0x30, 0x30, 0x30, 0x32, 0x18, 0x00, 0x30, 0x00, 0x42, 0x3a, 0x08,
	0x01, 0x10, 0x03, 0x18, 0x02, 0x20, 0x02, 0x28, 0x04, 0x30, 0x01, 0x38,
	0x01, 0x40, 0x02, 0x48, 0x00, 0x50, 0x02, 0x58, 0x60, 0x60, 0x60, 0x68,
	0x60, 0x70, 0x60, 0x78, 0x60, 0x80, 0x01, 0x60, 0x88, 0x01, 0x60, 0x90,
	0x01, 0x60, 0x98, 0x01, 0x00, 0xa0, 0x01, 0xa8, 0xc2, 0xa5, 0xe1, 0x05,
	0xa8, 0x01, 0x02, 0xb0, 0x01, 0x24, 0xb8, 0x01, 0x00, 0x4a, 0x08, 0x08,
	0x03, 0x10, 0x01, 0x18, 0x00, 0x20, 0x00, 0x52, 0x0b, 0x08, 0x64, 0x10,
	0xde, 0x0f, 0x18, 0x05, 0x20, 0x00, 0x28, 0x00, 0x8b, 0x02, 0xdf, 0xad

};

unsigned char dxpterminalPackage5_Event2P[79] = {
	0x01, 0x04, 0x44, 0x00, 0x12, 0x0e, 0x0a, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x1a, 0x00, 0x2a, 0x13,
	0x08, 0x8e, 0x0f, 0x12, 0x0c, 0x32, 0x37, 0x32, 0x32, 0x31, 0x31, 0x39,
	0x39, 0x30, 0x30, 0x30, 0x32, 0x18, 0x00, 0x30, 0x00, 0x4a, 0x08, 0x08,
	0x03, 0x10, 0x01, 0x18, 0x00, 0x20, 0x00, 0x52, 0x0b, 0x08, 0x64, 0x10,
	0xde, 0x0f, 0x18, 0x05, 0x20, 0x00, 0x28, 0x00, 0xa3, 0xc2, 0x27, 0x9c
};

unsigned char dxpterminalPackage6_Event2P[139] = {
	0x01, 0x04, 0x80, 0x00, 0x12, 0x0e, 0x0a, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x1a, 0x00, 0x2a, 0x13,
	0x08, 0xf0, 0x0e, 0x12, 0x0c, 0x32, 0x37, 0x32, 0x32, 0x31, 0x31, 0x39,
	0x39, 0x30, 0x30, 0x30, 0x32, 0x18, 0x00, 0x30, 0x00, 0x42, 0x3a, 0x08,
	0x01, 0x10, 0x03, 0x18, 0x02, 0x20, 0x02, 0x28, 0x04, 0x30, 0x01, 0x38,
	0x01, 0x40, 0x02, 0x48, 0x00, 0x50, 0x02, 0x58, 0x60, 0x60, 0x60, 0x68,
	0x60, 0x70, 0x60, 0x78, 0x60, 0x80, 0x01, 0x60, 0x88, 0x01, 0x60, 0x90,
	0x01, 0x60, 0x98, 0x01, 0x00, 0xa0, 0x01, 0xa6, 0xc2, 0xa5, 0xe1, 0x05,
	0xa8, 0x01, 0x02, 0xb0, 0x01, 0x24, 0xb8, 0x01, 0x00, 0x4a, 0x08, 0x08,
	0x03, 0x10, 0x01, 0x18, 0x00, 0x20, 0x00, 0x52, 0x0b, 0x08, 0x64, 0x10,
	0xde, 0x0f, 0x18, 0x05, 0x20, 0x00, 0x28, 0x00, 0x97, 0xd5, 0x79, 0xa6
};


#define HASP_STATUS_OK 0
unsigned int dxpHook_hasp_login(int feature_id, void* vendor_code, int hasp_handle) {
#ifdef _DEBUG
	OutputDebugStringA("hasp_login\n");
#endif
	return HASP_STATUS_OK;
}

unsigned int dxpHook_hasp_logout(int hasp_handle) {
#ifdef _DEBUG
	OutputDebugStringA("hasp_logout\n");
#endif
	return HASP_STATUS_OK;
}

unsigned int dxpHook_hasp_encrypt(int hasp_handle, unsigned char* buffer, unsigned int buffer_size) {
#ifdef _DEBUG
	OutputDebugStringA("hasp_encrypt\n");
#endif
	return HASP_STATUS_OK;
}

unsigned int dxpHook_hasp_decrypt(int hasp_handle, unsigned char* buffer, unsigned int buffer_size) {
#ifdef _DEBUG
	OutputDebugStringA("hasp_decrypt\n");
#endif
	return HASP_STATUS_OK;
}

unsigned int dxpHook_hasp_get_size(int hasp_handle, int hasp_fileid, unsigned int* hasp_size) {
#ifdef _DEBUG
	OutputDebugStringA("hasp_get_size\n");
#endif
	*hasp_size = 0xD40; // Max addressable size by the game... absmax is 4k
	return HASP_STATUS_OK;
}

unsigned int dxpHook_hasp_read(int hasp_handle, int hasp_fileid, unsigned int offset, unsigned int length, unsigned char* buffer) {
#ifdef _DEBUG
	OutputDebugStringA("hasp_read\n");
#endif
	memcpy(buffer, hasp_buffer + offset, length);
	return HASP_STATUS_OK;
}

unsigned int dxpHook_hasp_write(int hasp_handle, int hasp_fileid, unsigned int offset, unsigned int length, unsigned char* buffer) {
	return HASP_STATUS_OK;
}

unsigned char saveDatadxp[0x2000];
unsigned char mileDatadxp[0x08];

// BASE: 0x24E0 
// Campaing honor data: 2998, save 0xB8
// Story Mode Honor data: 25F0, save 0x98
// StoryModeNoLoseHonorData: 2C80, Copy 0,0x10, Copy 0x18,0x28 maybe 8 bytes more
// OtherHonorData: 2A90, Copy 0x60
// CampaignHonorData: 2698, Copy 0x48

//static int SaveCampaingHonorData2()
//{
//	memset(saveData, 0, 0x1000);
//	uintptr_t imageBase = (uintptr_t)GetModuleHandleA(0);
//	uintptr_t value = *(uintptr_t*)(imageBase + 0x1948F10);
//	value += 0x2698;
//	FILE* file = fopen(V("CampaignHonorData.sav"), V("wb"));
//	memcpy(saveData, (void *)value, 0x48);
//	fwrite(saveData, 1, 0x100, file);
//	fclose(file);
//	return 1;
//}
//
//static int SaveOtherHonorData()
//{
//	memset(saveData, 0, 0x1000);
//	uintptr_t imageBase = (uintptr_t)GetModuleHandleA(0);
//	uintptr_t value = *(uintptr_t*)(imageBase + 0x1948F10);
//	value += 0x2A90;
//	FILE* file = fopen(V("OtherHonorData.sav"), V("wb"));
//	memcpy(saveData, (void *)value, 0x60);
//	fwrite(saveData, 1, 0x100, file);
//	fclose(file);
//	return 1;
//}
//
//static int SaveStoryModeNoLoseHonorData()
//{
//	memset(saveData, 0, 0x1000);
//	uintptr_t imageBase = (uintptr_t)GetModuleHandleA(0);
//	uintptr_t value = *(uintptr_t*)(imageBase + 0x1948F10);
//	value += 0x2C80;
//	FILE* file = fopen(V("StoryModeNoLoseHonorData.sav"), V("wb"));
//	memcpy(saveData, (void *)value, 0x10);
//	value += 0x18;
//	memcpy(saveData, (void *)value, 0x28);
//	fwrite(saveData, 1, 0x100, file);
//	fclose(file);
//	return 1;
//}
//
//static int SaveCampaingHonorData()
//{
//	memset(saveData, 0, 0x1000);
//	uintptr_t imageBase = (uintptr_t)GetModuleHandleA(0);
//	uintptr_t value = *(uintptr_t*)(imageBase + 0x1948F10);
//	value += 0x2998;
//	FILE* file = fopen(V("campaing.sav"), V("wb"));
//	memcpy(saveData, (void *)value, 0xB8);
//	fwrite(saveData, 1, 0x100, file);
//	fclose(file);
//	return 1;
//}
//
//static int SaveStoryData()
//{
//	memset(saveData, 0, 0x1000);
//	uintptr_t imageBase = (uintptr_t)GetModuleHandleA(0);
//	uintptr_t value = *(uintptr_t*)(imageBase + 0x1948F10);
//	value += 0x25F0;
//	FILE* file = fopen(V("story.sav"), V("wb"));
//	memcpy(saveData, (void *)value, 0x98);
//	fwrite(saveData, 1, 0x100, file);
//	fclose(file);
//	return 1;
//}

//set system date patch by pockywitch
typedef bool (WINAPI* SETSYSTEMTIME)(SYSTEMTIME* in);
SETSYSTEMTIME pSetSystemTime = NULL;

bool WINAPI Hook_SetSystemTime(SYSTEMTIME* in)
{
	return TRUE;
}

static DWORD WINAPI forceFT(void* pArguments)
{
	while (true) {
		Sleep(16);
		auto carSaveBase = (uintptr_t*)(*(uintptr_t*)(imageBasedxplus + 0x01F7D578) + 0x268);
		auto powerAddress = (uintptr_t*)(*(uintptr_t*)(carSaveBase)+0xAC);
		auto handleAddress = (uintptr_t*)(*(uintptr_t*)(carSaveBase)+0xB8);
		injector::WriteMemory<uint8_t>(powerAddress, 0x10, true);
		injector::WriteMemory<uint8_t>(handleAddress, 0x10, true);
	}
	//debug
	/*
	std::ofstream myfile("debug.txt");
	myfile << "Base: ";
	myfile << carSaveBase;
	myfile << " Power: ";
	myfile << powerAddress;
	myfile << " Handling: ";
	myfile << handleAddress;
	myfile.close();
	*/
}

static DWORD WINAPI forceFTUpdate5(void* pArguments)
{
	while (true) {
		Sleep(16);
		auto carSaveBase = (uintptr_t*)(*(uintptr_t*)(imageBasedxplus + 0x02072478) + 0x268);
		auto powerAddress = (uintptr_t*)(*(uintptr_t*)(carSaveBase)+0xAC);
		auto handleAddress = (uintptr_t*)(*(uintptr_t*)(carSaveBase)+0xB8);
		injector::WriteMemory<uint8_t>(powerAddress, 0x10, true);
		injector::WriteMemory<uint8_t>(handleAddress, 0x10, true);
	}
}

static bool saveOk = false;
unsigned char carDatadxp[0xFF];
unsigned char starDatadxp[0x40]; //40 bytes for future proof
static int SaveOk()
{
	saveOk = true;
	return 1;
}

char carFileNamedxp[0xFF];
bool loadOkdxp = false;
bool customCardxp = false;

static void saveMileagedxp()
{
	
	//Mileage Write to "GAME/mileage.dat"
	auto mileageLocation = (uintptr_t*)(*(uintptr_t*)(imageBasedxplus + 0x1F7D578) + 0x280);
	//try this maybe, casting to int probably not right/not gonna work
	FILE* tempFile = fopen("mileage.dat", "wb");
	fwrite(mileageLocation, 1, sizeof(mileageLocation), tempFile);
	fclose(tempFile);
	
	//star save routine
	memset(starDatadxp, 0, 0x40);
	uintptr_t starBase = *(uintptr_t*)((*(uintptr_t*)(imageBasedxplus + 0x1F7D578)) + 0x110); //star pointer
	memcpy(starDatadxp + 0x00, (void*)(starBase + 0x248), 0x2); //dumps first 2 bytes from star pointer
	memcpy(starDatadxp + 0x04, (void*)(starBase + 0x254), 0x10); //dumps medal offsets from star pointer, 16 bytes
	FILE* starFile = fopen("star.bin", "wb");
	fwrite(starDatadxp, 1, sizeof(starDatadxp), tempFile);
	fclose(starFile);
}

static void LoadMileagedxp()
{
	
	memset(mileDatadxp, 0, 0x08);
	FILE* miles = fopen("mileage.dat", "rb");
	if (miles)
	{
		fseek(miles, 0, SEEK_END);
		int mileSize = ftell(miles);
		if (mileSize == 0x08)
		{
			fseek(miles, 0, SEEK_SET);
			fread(mileDatadxp, mileSize, 1, miles);
			uintptr_t mileMemory = *(uintptr_t*)(imageBasedxplus + 0x1F7D578);
			memcpy((void*)(mileMemory + 0x280), mileDatadxp + 0x00, 0x04);
			fclose(miles);
		}
	}

	memset(starDatadxp, 0, 0x40);
	FILE* starFile = fopen("star.bin", "rb");
	if (starFile)
	{
		fseek(starFile, 0, SEEK_END);
		int starSize = ftell(starFile);
		if (starSize == 0x40)
		{
			fseek(starFile, 0, SEEK_SET);
			fread(starDatadxp, starSize, 1, starFile);
			uintptr_t starBase = *(uintptr_t*)((*(uintptr_t*)(imageBasedxplus + 0x1F7D578)) + 0x110); //star pointer
			memcpy((void*)(starBase + 0x248), starDatadxp + 0x00, 0x2); //dumps first 2 bytes from star pointer
			memcpy((void*)(starBase + 0x254), starDatadxp + 0x04, 0x10); //dumps medal offsets from star pointer, 16 bytes
			fclose(starFile);
		}
	}

}


static int SaveGameData()
{
	if (!saveOk)
		return 1;

	// Car Profile saving
	memset(carDatadxp, 0, 0xFF);
	memset(carFileNamedxp, 0, 0xFF);

	//new multilevel
	uintptr_t carSaveBase = *(uintptr_t*)((*(uintptr_t*)(imageBasedxplus + 0x1F7D578)) + 0x268);

	memcpy(carDatadxp + 0x00, (void*)(carSaveBase + 0x0), 0xFF); //dumps whole region


	CreateDirectoryA("OpenParrot_Cars", nullptr);

	if (customCardxp)
	{
		sprintf(carFileNamedxp, ".\\OpenParrot_Cars\\custom.car");
	}
	else
	{
		sprintf(carFileNamedxp, ".\\OpenParrot_Cars\\%08X.car", *(DWORD*)(*(uintptr_t*)(*(uintptr_t*)(imageBasedxplus + 0x1F7D578) + 0x268) + 0x34));
	}

	FILE* file = fopen(carFileNamedxp, "wb");
	fwrite(carDatadxp, 1, 0xFF, file);
	fclose(file);

	saveMileagedxp();

	saveOk = false;
	return 1;

}

uintptr_t saveGameOffsetdxp;

//static int LoadCampaingHonorData2()
//{
//	memset(saveData, 0x0, 0x1000);
//	FILE* file = fopen(V("CampaignHonorData.sav"), V("rb"));
//	if (file)
//	{
//		fseek(file, 0, SEEK_END);
//		int fsize = ftell(file);
//		if (fsize == 0x100)
//		{
//			fseek(file, 0, SEEK_SET);
//			fread(saveData, fsize, 1, file);
//			uintptr_t imageBase = (uintptr_t)GetModuleHandleA(0);
//			uintptr_t value = *(uintptr_t*)(imageBase + 0x1948F10);
//			value += 0x2698;
//			memcpy((void *)value, saveData, 0x48);
//		}
//		fclose(file);
//	}
//	return 1;
//}
//
//static int LoadOtherHonorData()
//{
//	memset(saveData, 0x0, 0x1000);
//	FILE* file = fopen(V("OtherHonorData.sav"), V("rb"));
//	if (file)
//	{
//		fseek(file, 0, SEEK_END);
//		int fsize = ftell(file);
//		if (fsize == 0x100)
//		{
//			fseek(file, 0, SEEK_SET);
//			fread(saveData, fsize, 1, file);
//			uintptr_t imageBase = (uintptr_t)GetModuleHandleA(0);
//			uintptr_t value = *(uintptr_t*)(imageBase + 0x1948F10);
//			value += 0x2A90;
//			memcpy((void *)value, saveData, 0x60);
//		}
//		fclose(file);
//	}
//	return 1;
//}
//
//static int LoadStoryModeNoLoseHonorData()
//{
//	memset(saveData, 0x0, 0x1000);
//	FILE* file = fopen(V("StoryModeNoLoseHonorData.sav"), V("rb"));
//	if (file)
//	{
//		fseek(file, 0, SEEK_END);
//		int fsize = ftell(file);
//		if (fsize == 0x100)
//		{
//			fseek(file, 0, SEEK_SET);
//			fread(saveData, fsize, 1, file);
//			uintptr_t imageBase = (uintptr_t)GetModuleHandleA(0);
//			uintptr_t value = *(uintptr_t*)(imageBase + 0x1948F10);
//			value += 0x2C80;
//			//memcpy((void *)value, saveData, 0x10);
//			value += 0x18;
//			memcpy((void *)value, saveData, 0x28);
//		}
//		fclose(file);
//	}
//	return 1;
//}
//
//static int LoadCampaingHonorData()
//{
//	memset(saveData, 0x0, 0x1000);
//	FILE* file = fopen(V("campaing.sav"), V("rb"));
//	if (file)
//	{
//		fseek(file, 0, SEEK_END);
//		int fsize = ftell(file);
//		if (fsize == 0x100)
//		{
//			fseek(file, 0, SEEK_SET);
//			fread(saveData, fsize, 1, file);
//			uintptr_t imageBase = (uintptr_t)GetModuleHandleA(0);
//			uintptr_t value = *(uintptr_t*)(imageBase + 0x1948F10);
//			value += 0x24E0;
//			memcpy((void *)value, saveData, 0xB8);
//		}
//		fclose(file);
//	}
//	return 1;
//}
//
//static int LoadStoryData()
//{
//	memset(saveData, 0x0, 0x1000);
//	FILE* file = fopen(V("story.sav"), V("rb"));
//	if (file)
//	{
//		fseek(file, 0, SEEK_END);
//		int fsize = ftell(file);
//		if (fsize == 0x100)
//		{
//			fseek(file, 0, SEEK_SET);
//			fread(saveData, fsize, 1, file);
//			uintptr_t imageBase = (uintptr_t)GetModuleHandleA(0);
//			uintptr_t value = *(uintptr_t*)(imageBase + 0x1948F10);
//			value += 0x25F0;
//			memcpy((void *)value, saveData, 0x98);
//		}
//		fclose(file);
//	}
//	return 1;
//}

static int LoadGameData()
{
	saveOk = false;
	memset(saveDatadxp, 0x0, 0x2000);
	FILE* file = fopen("openprogress.sav", "rb");
	if (file)
	{
		fseek(file, 0, SEEK_END);
		int fsize = ftell(file);
		if (fsize == 0x2000)
		{
			fseek(file, 0, SEEK_SET);
			fread(saveDatadxp, fsize, 1, file);
			uintptr_t value = *(uintptr_t*)(imageBasedxplus + 0x1948F10);
			value = *(uintptr_t*)(value + 0x108);

			// First page
			//memcpy((void *)(value), saveData, 0x48);
			memcpy((void *)(value + 0x10), saveDatadxp + 0x10, 0x20);
			memcpy((void *)(value + 0x40), saveDatadxp + 0x40, 0x08);
			//memcpy((void *)(value + 0x48 + 8), saveData + 0x48 + 8, 0x20);
			memcpy((void *)(value + 0x48 + 8), saveDatadxp + 0x48 + 8, 0x08);
			memcpy((void *)(value + 0x48 + 24), saveDatadxp + 0x48 + 24, 0x08);
			memcpy((void *)(value + 0x48 + 32), saveDatadxp + 0x48 + 32, 0x08);

			// Second page
			value += 0x110;
			memcpy((void *)(value), saveDatadxp + 0x110, 0x90);
			value -= 0x110;

			// Third Page
			value += 0x1B8;
			memcpy((void *)(value), saveDatadxp + 0x1B8, 0x48);
			memcpy((void *)(value + 0x48 + 8), saveDatadxp + 0x1B8 + 0x48 + 8, 0x28);
			value -= 0x1B8;

			// Fourth page
			value += 0x240;
			memcpy((void *)(value), saveDatadxp + 0x240, 0x68);
			value -= 0x240;

			// Fifth page
			value += 0x2B8;
			memcpy((void *)(value), saveDatadxp + 0x2B8, 0x88);
			value -= 0x2B8;

			loadOkdxp = true;

			//+ 0x80

			//+ [0x340]

			// [[[[0000000005CE5850] + 108] + 340] + 50] + 50
			// [[[[0000000005CE5850] + 108] + 340] + 50] + 54
			// wmn5r.exe + 1948BF8
			//TA stuff

			//[[[[magic_rva]+108]+340]+50]

			//value += 0x24E0;
			// First chunk
			//memcpy((void *)(value + 0x16), saveData + 0x16, 0x28);
			////
			//memcpy((void *)(value + 0x40), saveData + 0x40, 0x18);
			////
			//memcpy((void *)(value + 0x60), saveData + 0x60, 0x20);
			////
			//memcpy((void *)(value + 0x90), saveData + 0x90, 0x28);
			////
			//memcpy((void *)(value + 0xC0), saveData + 0xC0, 0x10);
			////
			//memcpy((void *)(value + 0xD8), saveData + 0xD8, 0x28); // OK
			////
			//memcpy((void *)(value + 0x110), saveData + 0x110, 0x98);
			////
			//memcpy((void *)(value + 0x1B8), saveData + 0x1B8, 0x48);
			////
			//memcpy((void *)(value + 0x208), saveData + 0x208, 0x28);
			////
			//memcpy((void *)(value + 0x240), saveData + 0x240, 0x68);
			////
			//memcpy((void *)(value + 0x2B8), saveData + 0x2B8, 0x88);
			//
			//memcpy((void *)(value + 0x370), saveData + 0x370, 0x10);
			////
			//memcpy((void *)(value + 0x388), saveData + 0x388, 0x90);
			////
			//memcpy((void *)(value + 0x420), saveData + 0x420, 0x18);
			////
			//memcpy((void *)(value + 0x440), saveData + 0x440, 0x18);
			////
			//memcpy((void *)(value + 0x460), saveData + 0x460, 0x48);
			////
			//memcpy((void *)(value + 0x4B8), saveData + 0x4B8, 0xB8);
			////
			//memcpy((void *)(value + 0x578), saveData + 0x578, 0x08);
			////
			//memcpy((void *)(value + 0x5A8), saveData + 0x5A8, 0x68);
			////
			//memcpy((void *)(value + 0x628), saveData + 0x628, 0x48);
			////
			//memcpy((void *)(value + 0x688), saveData + 0x688, 0x48);
			////
			//memcpy((void *)(value + 0x6E8), saveData + 0x6E8, 0xA8);
			////
			//memcpy((void *)(value + 0x7A0), saveData + 0x7A0, 0x10);
			////
			//memcpy((void *)(value + 0x7B8), saveData + 0x7B8, 0x28);
			////
			//memcpy((void *)(value + 0x7E8), saveData + 0x7E8, 0x10);
			////
			////memcpy((void *)(value + 0x800), saveData + 0x800, 0x48); // Problem
			//////
			//memcpy((void *)(value + 0x850), saveData + 0x850, 0x08);
			//
			//memcpy((void *)(value + 0x860), saveData + 0x860, 0x08);
			//////
			//memcpy((void *)(value + 0x870), saveData + 0x870, 0x18);
			////
			//memcpy((void *)(value + 0x890), saveData + 0x890, 0x40);
			////
			//memcpy((void *)(value + 0x8E0), saveData + 0x8E0, 0x10);
			////
			//memcpy((void *)(value + 0x8F8), saveData + 0x8F8, 0x28);
			////
			//memcpy((void *)(value + 0x928), saveData + 0x928, 0x10);
			////
			//memcpy((void *)(value + 0x940), saveData + 0x940, 0x48); // Problem
		}
		fclose(file);
	}
	//LoadStoryData();
	//LoadCampaingHonorData();
	//LoadStoryModeNoLoseHonorData();
	//LoadOtherHonorData();
	//LoadCampaingHonorData2();
	return 1;
}



static void LoadWmmt5CarData()
{
	std::this_thread::sleep_for(std::chrono::milliseconds(1000));

//	if (!loadOkdxp)
//		return;
	customCardxp = false;
	memset(carDatadxp, 0, 0xFF);
	memset(carFileNamedxp, 0, 0xFF);
	CreateDirectoryA("OpenParrot_Cars", nullptr);

	LoadMileagedxp();

	// check for custom car
	sprintf(carFileNamedxp, ".\\OpenParrot_Cars\\custom.car");
	if (FileExists(carFileNamedxp))
	{
		FILE* file = fopen(carFileNamedxp, "rb");
		if (file)
		{
			fseek(file, 0, SEEK_END);
			int fsize = ftell(file);
			if (fsize == 0xFF)
			{
				fseek(file, 0, SEEK_SET);
				fread(carDatadxp, fsize, 1, file);
				uintptr_t carSaveLocation = *(uintptr_t*)((*(uintptr_t*)(imageBasedxplus + 0x1F7D578)) + 0x268);
				memcpy((void*)(carSaveLocation + 0xAC), carDatadxp + 0xAC, 0x1); //power
				memcpy((void*)(carSaveLocation + 0xB8), carDatadxp + 0xB8, 0x1); //handling
				memcpy((void*)(carSaveLocation + 0x28), carDatadxp + 0x28, 0x1); //region
				memcpy((void*)(carSaveLocation + 0x34), carDatadxp + 0x34, 0x1); //carID
				memcpy((void*)(carSaveLocation + 0x38), carDatadxp + 0x38, 0x1); //defaultColor
				memcpy((void*)(carSaveLocation + 0x3C), carDatadxp + 0x3C, 0x1); //customColor
				memcpy((void*)(carSaveLocation + 0x40), carDatadxp + 0x40, 0x1); //rims
				memcpy((void*)(carSaveLocation + 0x44), carDatadxp + 0x44, 0x1); //rimColor
				memcpy((void*)(carSaveLocation + 0x48), carDatadxp + 0x48, 0x1); //aero
				memcpy((void*)(carSaveLocation + 0x4C), carDatadxp + 0x4C, 0x1); //hood
				memcpy((void*)(carSaveLocation + 0x58), carDatadxp + 0x58, 0x1); //wang
				memcpy((void*)(carSaveLocation + 0x5C), carDatadxp + 0x5C, 0x1); //mirror
				memcpy((void*)(carSaveLocation + 0x60), carDatadxp + 0x60, 0x1); //sticker
				memcpy((void*)(carSaveLocation + 0x64), carDatadxp + 0x64, 0x1); //stickerVariant
				memcpy((void*)(carSaveLocation + 0x88), carDatadxp + 0x88, 0x1); //roofSticker
				memcpy((void*)(carSaveLocation + 0x8C), carDatadxp + 0x8C, 0x1); //roofStickerVariant
				memcpy((void*)(carSaveLocation + 0x90), carDatadxp + 0x90, 0x1); //neon
				memcpy((void*)(carSaveLocation + 0x94), carDatadxp + 0x94, 0x1); //trunk
				memcpy((void*)(carSaveLocation + 0x98), carDatadxp + 0x98, 0x1); //plateFrame
				memcpy((void*)(carSaveLocation + 0xA0), carDatadxp + 0xA0, 0x4); //plateNumber
				memcpy((void*)(carSaveLocation + 0xA4), carDatadxp + 0xA4, 0x1); //vinyl_body_challenge_prefecture_1~15
				memcpy((void*)(carSaveLocation + 0xA8), carDatadxp + 0xA8, 0x1); //vinyl_body_challenge_prefecture
				memcpy((void*)(carSaveLocation + 0xBC), carDatadxp + 0xBC, 0x1); //rank
				memcpy((void*)(carSaveLocation + 0xF0), carDatadxp + 0xF0, 0x1); //title??

				customCardxp = true;
			}
			loadOkdxp = false;
			fclose(file);
			return;
		}
	}
	if (ToBool(config["Tune"]["Force Full Tune"]))
	{
		CreateThread(0, 0, forceFT, 0, 0, 0);
	}
	memset(carFileNamedxp, 0, 0xFF);
	// Load actual car if available
	sprintf(carFileNamedxp, ".\\OpenParrot_Cars\\%08X.car", *(DWORD*)(*(uintptr_t*)(*(uintptr_t*)(imageBasedxplus + 0x1F7D578) + 0x268) + 0x34));
	if(FileExists(carFileNamedxp))
	{
		FILE* file = fopen(carFileNamedxp, "rb");
		if (file)
		{
			fseek(file, 0, SEEK_END);
			int fsize = ftell(file);
			if (fsize == 0xFF)
			{	
				fseek(file, 0, SEEK_SET);
				fread(carDatadxp, fsize, 1, file);
				uintptr_t carSaveLocation = *(uintptr_t*)((*(uintptr_t*)(imageBasedxplus + 0x1F7D578)) + 0x268);
				memcpy((void*)(carSaveLocation + 0xAC), carDatadxp + 0xAC, 0x1); //power
				memcpy((void*)(carSaveLocation + 0xB8), carDatadxp + 0xB8, 0x1); //handling
				memcpy((void*)(carSaveLocation + 0x28), carDatadxp + 0x28, 0x1); //region
				memcpy((void*)(carSaveLocation + 0x34), carDatadxp + 0x34, 0x1); //carID
				memcpy((void*)(carSaveLocation + 0x38), carDatadxp + 0x38, 0x1); //defaultColor
				memcpy((void*)(carSaveLocation + 0x3C), carDatadxp + 0x3C, 0x1); //customColor
				memcpy((void*)(carSaveLocation + 0x40), carDatadxp + 0x40, 0x1); //rims
				memcpy((void*)(carSaveLocation + 0x44), carDatadxp + 0x44, 0x1); //rimColor
				memcpy((void*)(carSaveLocation + 0x48), carDatadxp + 0x48, 0x1); //aero
				memcpy((void*)(carSaveLocation + 0x4C), carDatadxp + 0x4C, 0x1); //hood
				memcpy((void*)(carSaveLocation + 0x58), carDatadxp + 0x58, 0x1); //wang
				memcpy((void*)(carSaveLocation + 0x5C), carDatadxp + 0x5C, 0x1); //mirror
				memcpy((void*)(carSaveLocation + 0x60), carDatadxp + 0x60, 0x1); //sticker
				memcpy((void*)(carSaveLocation + 0x64), carDatadxp + 0x64, 0x1); //stickerVariant
				memcpy((void*)(carSaveLocation + 0x88), carDatadxp + 0x88, 0x1); //roofSticker
				memcpy((void*)(carSaveLocation + 0x8C), carDatadxp + 0x8C, 0x1); //roofStickerVariant
				memcpy((void*)(carSaveLocation + 0x90), carDatadxp + 0x90, 0x1); //neon
				memcpy((void*)(carSaveLocation + 0x94), carDatadxp + 0x94, 0x1); //trunk
				memcpy((void*)(carSaveLocation + 0x98), carDatadxp + 0x98, 0x1); //plateFrame
				memcpy((void*)(carSaveLocation + 0xA0), carDatadxp + 0xA0, 0x4); //plateNumber
				memcpy((void*)(carSaveLocation + 0xA4), carDatadxp + 0xA4, 0x1); //vinyl_body_challenge_prefecture_1~15
				memcpy((void*)(carSaveLocation + 0xA8), carDatadxp + 0xA8, 0x1); //vinyl_body_challenge_prefecture
				memcpy((void*)(carSaveLocation + 0xBC), carDatadxp + 0xBC, 0x1); //rank
				memcpy((void*)(carSaveLocation + 0xF0), carDatadxp + 0xF0, 0x1); //title??
			}
			fclose(file);
		}
	}
	loadOkdxp = false;
}

static void loadCar()
{
	std::thread t1(LoadWmmt5CarData);
	t1.detach();
}

static void loadCarUpdate5()
{
	if (ToBool(config["Tune"]["Force Full Tune"]))
	{
		CreateThread(0, 0, forceFTUpdate5, 0, 0, 0);
	}
}

static int ReturnTrue()
{
	return 1;
}

void GenerateDongleDataDxp(bool isTerminal)
{
	memset(hasp_buffer, 0, 0xD40);
	hasp_buffer[0] = 0x01;
	hasp_buffer[0x13] = 0x01;
	hasp_buffer[0x17] = 0x0A;
	hasp_buffer[0x1B] = 0x04;
	hasp_buffer[0x1C] = 0x3B;
	hasp_buffer[0x1D] = 0x6B;
	hasp_buffer[0x1E] = 0x40;
	hasp_buffer[0x1F] = 0x87;

	hasp_buffer[0x23] = 0x01;
	hasp_buffer[0x27] = 0x0A;
	hasp_buffer[0x2B] = 0x04;
	hasp_buffer[0x2C] = 0x3B;
	hasp_buffer[0x2D] = 0x6B;
	hasp_buffer[0x2E] = 0x40;
	hasp_buffer[0x2F] = 0x87;

	if(isTerminal)
	{
		memcpy(hasp_buffer + 0xD00, "278311042069", 12); //272211990002
		hasp_buffer[0xD3E] = 0x6B;
		hasp_buffer[0xD3F] = 0x94;
	}
	else
	{
		memcpy(hasp_buffer + 0xD00, "278313042069", 12); //272213990002
		hasp_buffer[0xD3E] = 0x6D;
		hasp_buffer[0xD3F] = 0x92;
	}
}


char customNamedxp[256];


static DWORD WINAPI SpamcustomNamedxp(LPVOID)
{
	while (true)
	{
		
		Sleep(50);
		void *value = (void *)(imageBasedxplus + 0x1F846F0);
		memcpy(value, customNamedxp, strlen(customNamedxp) + 1);
		
	}
}

static DWORD WINAPI SpamMulticast(LPVOID)
{
	WSADATA wsaData;
	WSAStartup(MAKEWORD(2, 2), &wsaData);

	SOCKET sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

	int ttl = 255;
	setsockopt(sock, IPPROTO_IP, IP_MULTICAST_TTL, (char*)&ttl, sizeof(ttl));

	int reuse = 1;
	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char*)&reuse, sizeof(reuse));

	setsockopt(sock, IPPROTO_IP, IP_MULTICAST_LOOP, (char*)&reuse, sizeof(reuse));

	sockaddr_in bindAddr = { 0 };
	bindAddr.sin_family = AF_INET;
	bindAddr.sin_addr.s_addr = inet_addr(ipaddrdxplus);
	bindAddr.sin_port = htons(50765);
	bind(sock, (sockaddr*)&bindAddr, sizeof(bindAddr));
	

	ip_mreq mreq;
	mreq.imr_multiaddr.s_addr = inet_addr("225.0.0.1");
	mreq.imr_interface.s_addr = inet_addr(ipaddrdxplus);

	setsockopt(sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, (char*)&mreq, sizeof(mreq));

	const uint8_t* byteSequences_Free[] = {
		dxpterminalPackage1_Free,
		dxpterminalPackage2_Free,
		dxpterminalPackage3_Free,
		dxpterminalPackage4_Free,
		dxpterminalPackage5_Free,
		dxpterminalPackage6_Free,
	};

	const size_t byteSizes_Free[] = {
		sizeof(dxpterminalPackage1_Free),
		sizeof(dxpterminalPackage2_Free),
		sizeof(dxpterminalPackage3_Free),
		sizeof(dxpterminalPackage4_Free),
		sizeof(dxpterminalPackage5_Free),
		sizeof(dxpterminalPackage6_Free),
	};
	
	const uint8_t* byteSequences_Event2P[] = {
		dxpterminalPackage1_Event2P,
		dxpterminalPackage2_Event2P,
		dxpterminalPackage3_Event2P,
		dxpterminalPackage4_Event2P,
		dxpterminalPackage5_Event2P,
		dxpterminalPackage6_Event2P,
	};

	const size_t byteSizes_Event2P[] = {
		sizeof(dxpterminalPackage1_Event2P),
		sizeof(dxpterminalPackage2_Event2P),
		sizeof(dxpterminalPackage3_Event2P),
		sizeof(dxpterminalPackage4_Event2P),
		sizeof(dxpterminalPackage5_Event2P),
		sizeof(dxpterminalPackage6_Event2P),
	};

	const uint8_t* byteSequences_Event4P[] = {
		dxpterminalPackage1_Event4P,
		dxpterminalPackage2_Event4P,
		dxpterminalPackage3_Event4P,
		dxpterminalPackage4_Event4P,
		dxpterminalPackage5_Event4P,
		dxpterminalPackage6_Event4P,
	};

	const size_t byteSizes_Event4P[] = {
		sizeof(dxpterminalPackage1_Event4P),
		sizeof(dxpterminalPackage2_Event4P),
		sizeof(dxpterminalPackage3_Event4P),
		sizeof(dxpterminalPackage4_Event4P),
		sizeof(dxpterminalPackage5_Event4P),
		sizeof(dxpterminalPackage6_Event4P),
	};

	const uint8_t* byteSequences_Coin[] = {
		dxpterminalPackage1_Coin,
		dxpterminalPackage2_Coin,
		dxpterminalPackage3_Coin,
		dxpterminalPackage4_Coin,
		dxpterminalPackage5_Coin,
		dxpterminalPackage6_Coin,
	};

	const size_t byteSizes_Coin[] = {
		sizeof(dxpterminalPackage1_Coin),
		sizeof(dxpterminalPackage2_Coin),
		sizeof(dxpterminalPackage3_Coin),
		sizeof(dxpterminalPackage4_Coin),
		sizeof(dxpterminalPackage5_Coin),
		sizeof(dxpterminalPackage6_Coin),
	};
	
	sockaddr_in toAddr = { 0 };
	toAddr.sin_family = AF_INET;
	toAddr.sin_addr.s_addr = inet_addr("225.0.0.1");
	toAddr.sin_port = htons(50765);
	
	
	isFreePlay = ToBool(config["General"]["FreePlay"]);
	isEventMode2P = ToBool(config["TerminalEmuConfig"]["2P Event Mode"]);
	isEventMode4P = ToBool(config["TerminalEmuConfig"]["4P Event Mode"]);
	
	
	if (isFreePlay)
	{
		if (isEventMode2P) {
			while (true) for (int i = 0; i < _countof(byteSequences_Event2P); i++)
			{
				sendto(sock, (const char*)byteSequences_Event2P[i], byteSizes_Event2P[i], 0, (sockaddr*)&toAddr, sizeof(toAddr));
				Sleep(8);
			}
		}
		else if (isEventMode4P) {
			while (true) for (int i = 0; i < _countof(byteSequences_Event4P); i++)
			{
				sendto(sock, (const char*)byteSequences_Event4P[i], byteSizes_Event4P[i], 0, (sockaddr*)&toAddr, sizeof(toAddr));
				Sleep(8);
			}
		}
		else {
			while (true) for (int i = 0; i < _countof(byteSequences_Free); i++)
			{
				sendto(sock, (const char*)byteSequences_Free[i], byteSizes_Free[i], 0, (sockaddr*)&toAddr, sizeof(toAddr));
				Sleep(8);
			}
		}
	}
	
	while (true) for (int i = 0; i < _countof(byteSequences_Coin); i++)
	{
		sendto(sock, (const char*)byteSequences_Coin[i], byteSizes_Coin[i], 0, (sockaddr*)&toAddr, sizeof(toAddr));
		Sleep(8);
	}
}

/*
extern int* ffbOffset;
extern int* ffbOffset2;
extern int* ffbOffset3;
extern int* ffbOffset4;

DWORD WINAPI Wmmt5FfbCollector(void* ctx)
{
	uintptr_t imageBase = (uintptr_t)GetModuleHandleA(0);
	while (true)
	{
		*ffbOffset = *(DWORD *)(imageBase + 0x196F188);
		*ffbOffset2 = *(DWORD *)(imageBase + 0x196F18c);
		*ffbOffset3 = *(DWORD *)(imageBase + 0x196F190);
		*ffbOffset4 = *(DWORD *)(imageBase + 0x196F194);
		Sleep(10);
	}
}*/

static InitFunction Wmmt5Func([]()
{/*
	FILE* fileF = _wfopen(L"Fsetting.lua.gz", L"r");
	if (fileF == NULL)
	{
		FILE* settingsF = _wfopen(L"Fsetting.lua.gz", L"wb");
		fwrite(settingData, 1, sizeof(settingData), settingsF);
		fclose(settingsF);
	}
	else
	{
		fclose(fileF);
	}

	FILE* fileG = _wfopen(L"Gsetting.lua.gz", L"r");
	if (fileG == NULL)
	{
		FILE* settingsG = _wfopen(L"Gsetting.lua.gz", L"wb");
		fwrite(settingData, 1, sizeof(settingData), settingsG);
		fclose(settingsG);
	}
	else
	{
		fclose(fileG);
	}*/

	bool isUpdate5 = false;
	if (ToBool(config["Update5"]["Enable Update5"]))
	{
		isUpdate5 = true;
	}

	bool isTerminal = false;
	if (ToBool(config["General"]["TerminalMode"]))
	{
		isTerminal = true;
	}
	


	std::string networkip = config["General"]["NetworkAdapterIP"];
	if (!networkip.empty())
	{
		//strcpy(ipaddr, networkip.c_str());
		ipaddrdxplus = networkip.c_str();
	}

	hookPort = "COM3";
	imageBasedxplus = (uintptr_t)GetModuleHandleA(0);
	MH_Initialize();

	// Hook dongle funcs
	MH_CreateHookApi(L"hasp_windows_x64_106482.dll", "hasp_write", dxpHook_hasp_write, NULL);
	MH_CreateHookApi(L"hasp_windows_x64_106482.dll", "hasp_read", dxpHook_hasp_read, NULL);
	MH_CreateHookApi(L"hasp_windows_x64_106482.dll", "hasp_get_size", dxpHook_hasp_get_size, NULL);
	MH_CreateHookApi(L"hasp_windows_x64_106482.dll", "hasp_decrypt", dxpHook_hasp_decrypt, NULL);
	MH_CreateHookApi(L"hasp_windows_x64_106482.dll", "hasp_encrypt", dxpHook_hasp_encrypt, NULL);
	MH_CreateHookApi(L"hasp_windows_x64_106482.dll", "hasp_logout", dxpHook_hasp_logout, NULL);
	MH_CreateHookApi(L"hasp_windows_x64_106482.dll", "hasp_login", dxpHook_hasp_login, NULL);



	GenerateDongleDataDxp(isTerminal);


	//prevents game from setting time, thanks pockywitch!
	MH_CreateHookApi(L"KERNEL32", "SetSystemTime", Hook_SetSystemTime, reinterpret_cast<LPVOID*>(&pSetSystemTime));

	// Patch some check TEMP DISABLE AS WELL OVER HERE
	// 0F 94 C0 84 C0 0F 94 C0 84 C0 75 05 45 32 E4 EB 03 41 B4 01
	// FOUND ON 21, 10
	// NOT WORKING 1
	// 0F 94 C0 84 C0 0F 94 C0 84 C0 75 05 45 32 ?? EB
	// FOUND ON 1
	//injector::WriteMemory<uint8_t>(imageBase + 0x6286EC, 0, true); 
	injector::WriteMemory<uint8_t>(hook::get_pattern("85 C9 0F 94 C0 84 C0 0F 94 C0 84 C0 75 ? 40 32 F6 EB ?", 0x15), 0, true); //patches out dongle error2 (doomer)

	// Patch some jnz
	// 83 C0 FD 83 F8 01 0F 87 B4 00 00 00 83 BF D0 06 00 00 3C 73 29 48 8D 8D 60 06 00 00
	// FOUND ON 21, 10
	// NOT FOUND: 1
	// 83 C0 FD 83 F8 01 0F 87 B4 00 00 00
	// FOUND ON 1
	//injector::MakeNOP(imageBase + 0x628AE0, 6);
	//THIS injector::MakeNOP(hook::get_pattern("83 C0 FD 83 F8 01 0F 87 B4 00 00 00", 6), 6);
	injector::MakeNOP(hook::get_pattern("83 C0 FD 83 F8 01 76 ? 49 8D ? ? ? ? 00 00"), 6);

	// Patch some shit
	// 83 FA 04 0F 8C 1E 01 00 00 4C 89 44 24 18 4C 89 4C 24 20
	// FOUND ON 21, 10, 1
	// NOT FOUND:
	//injector::WriteMemory<uint8_t>(imageBase + 0x7B9882, 0, true);
	//THIS injector::WriteMemory<uint8_t>(hook::get_pattern("83 FA 04 0F 8C 1E 01 00 00 4C 89 44 24 18 4C 89 4C 24 20", 2), 0, true);
		
	// Skip weird camera init that stucks entire pc on certain brands. TESTED ONLY ON 05!!!!
	if (ToBool(config["General"]["WhiteScreenFix"]))
	{
		injector::WriteMemory<DWORD>(hook::get_pattern("48 8B C4 55 57 41 54 41 55 41 56 48 8D 68 A1 48 81 EC 90 00 00 00 48 C7 45 D7 FE FF FF FF 48 89 58 08 48 89 70 18 45 33 F6 4C 89 75 DF 33 C0 48 89 45 E7", 0), 0x90C3C032, true);
	}

	// Patch some call
	// 45 33 C0 BA 65 09 00 00 48 8D 4D B0 E8 ?? ?? ?? ?? 48 8B 08
	// FOUND ON 21, 10, 1
	//injector::MakeNOP(imageBase + 0x7DADED, 5);
	//THIS injector::MakeNOP(hook::get_pattern("45 33 C0 BA 65 09 00 00 48 8D 4D B0 E8 ? ? ? ? 48 8B 08", 12), 5);

	{
		// 199AE18 TIME OFFSET RVA temp disable ALL JNZ PATCH

		auto location = hook::get_pattern<char>("41 3B C7 74 0E 48 8D 8F B8 00 00 00 BA F6 01 00 00 EB 6E 48 8D 8F A0 00 00 00");
		// Patch some jnz
		// 41 3B C7 74 0E 48 8D 8F B8 00 00 00 BA F6 01 00 00 EB 6E 48 8D 8F A0 00 00 00
		// FOUND ON 21, 10, 1
		//injector::WriteMemory<uint8_t>(imageBase + 0x943F52, 0xEB, true);
		injector::WriteMemory<uint8_t>(location + 3, 0xEB, true); //patches content router (doomer)

		// Skip some jnz
		//injector::MakeNOP(imageBase + 0x943F71, 2);
		injector::MakeNOP(location + 0x22, 2); //patches ip addr error again (doomer)

		// Skip some jnz
		//injector::MakeNOP(imageBase + 0x943F82, 2);
		injector::MakeNOP(location + 0x33, 2); //patches ip aaddr error(doomer)
	}

	// Skip DebugBreak on MFStartup fail
	// 48 83 EC 28 33 D2 B9 70 00 02 00 E8 ?? ?? ?? ?? 85 C0 79 06
	// FOUND on 21, 1
	{
		/*
		auto location = hook::get_pattern<char>("48 83 EC 28 33 D2 B9 70 00 02 00 E8 ? ? ? ? 85 C0 79 06");
		injector::WriteMemory<uint8_t>(location + 0x12, 0xEB, true);
		*/
	}
	//safeJMP(hook::get_pattern(V("48 83 EC 28 33 D2 B9 70 00 02 00 E8 ? ? ? ? 85 C0 79 06")), ReturnTrue);

	if (isTerminal)
	{
		// Patch some func to 1
		// 
		// FOUND ON 21, 10, 1
		// NOT FOUND:
		//safeJMP(imageBase + 0x7BE440, ReturnTrue);
		safeJMP(hook::get_pattern("0F B6 41 05 2C 30 3C 09 77 04 0F BE C0 C3 83 C8 FF C3"), ReturnTrue);
		//safeJMP(imageBase + 0x89D420, ReturnTrue);

		// Patch some func to 1
		// 40 53 48 83 EC 20 48 83 39 00 48 8B D9 75 28 48 8D ?? ?? ?? ?? 00 48 8D ?? ?? ?? ?? 00 41 B8 ?? ?? 00 00 FF 15 ?? ?? ?? ?? 4C 8B 1B 41 0F B6 43 78
		// FOUND ON 21, 10, 1
		//safeJMP(imageBase + 0x7CF8D0, ReturnTrue); 
		safeJMP(hook::get_pattern("8B 01 0F B6 40 78 C3 CC CC CC CC"), ReturnTrue);
		//safeJMP(imageBase + 0x8B5190, ReturnTrue); 
	}
	else
	{
		// Disregard terminal scanner stuff.
		// 48 8B 18 48 3B D8 0F 84 88 00 00 00 39 7B 1C 74 60 80 7B 31 00 75 4F 48 8B 43 10 80 78 31 00
		// FOUND ON 21, 10, 1
		//injector::MakeNOP(imageBase + 0x91E1AE, 6);
		//injector::MakeNOP(imageBase + 0x91E1B7, 2);
		//injector::MakeNOP(imageBase + 0x91E1BD, 2);
		
		{
		
			/*
			auto location = hook::get_pattern<char>("48 8B 18 48 3B D8 0F 84 8B 00 00 00 0F 1F 80 00 00 00 00 39 73 1C 74 5C 80 7B 31 00");
			//injector::MakeNOP(location + 6, 6); // 6
			injector::MakeNOP(location + 0xF, 2); // 0xF
			//injector::MakeNOP(location + 0x15, 2); // 0x15
			*/
			//injector::MakeNOP(imageBasedxplus + 0x9F2BB3, 2); //terminal on same machine check
			injector::MakeNOP(hook::get_pattern("74 ? 80 7B 31 00 75 ? 48 8B 43 10 80 78 31 00 75 1A 48 8B D8 48 8B 00 80 78 31 00 75 ? 48 8B D8"), 2);
		}
		

		// spam thread
		if (ToBool(config["General"]["TerminalEmulator"]))
		{
			CreateThread(0, 0, SpamMulticast, 0, 0, 0);			
		}
	}

	auto chars = { 'F', 'G' };

	for (auto cha : chars)
	{
		auto patterns = hook::pattern(va("%02X 3A 2F", cha));

		if (patterns.size() > 0)
		{
			for (int i = 0; i < patterns.size(); i++)
			{
				char* text = patterns.get(i).get<char>(0);
				std::string text_str(text);

				std::string to_replace = va("%c:/", cha);
				std::string replace_with = va("./%c", cha);

				std::string replaced = text_str.replace(0, to_replace.length(), replace_with);

				injector::WriteMemoryRaw(text, (char*)replaced.c_str(), replaced.length() + 1, true);
			}
		}
	}

	if (ToBool(config["General"]["SkipMovies"]))
	{
		// Skip movies fuck you wmmt5
		//safeJMP(imageBase + 0x806020, ReturnTrue);
	}

	std::string value = config["General"]["CustomName"];
	if (!value.empty())
	{
		if (!isUpdate5)
		{
			memset(customNamedxp, 0, 256);
			strcpy(customNamedxp, value.c_str());
			CreateThread(0, 0, SpamcustomNamedxp, 0, 0, 0);
		}
	}

	// Save story stuff (only 05)
	{

		// skip erasing of temp card data
		//injector::WriteMemory<uint8_t>(imageBase + 0xA35CA3, 0xEB, true);
		/*
		// Skip erasing of temp card
		safeJMP(imageBase + 0x54DCE1, LoadGameData);
		safeJMP(imageBase + 0x5612F0, ReturnTrue);
		safeJMP(imageBase + 0x5753C0, ReturnTrue);
		safeJMP(imageBase + 0x57DF10, ReturnTrue);

		safeJMP(imageBase + 0x92DB20, ReturnTrue);
		safeJMP(imageBase + 0x5628C0, ReturnTrue);
		safeJMP(imageBase + 0x579090, ReturnTrue);

		// Skip more
		safeJMP(imageBase + 0x54B0F0, ReturnTrue);
		safeJMP(imageBase + 0x909DB0, ReturnTrue);
		safeJMP(imageBase + 0x59FD90, ReturnTrue);
		safeJMP(imageBase + 0x5A0030, ReturnTrue);
		safeJMP(imageBase + 0x915370, ReturnTrue);
		safeJMP(imageBase + 0x5507A0, ReturnTrue);
		safeJMP(imageBase + 0x561290, ReturnTrue);

		safeJMP(imageBase + 0x5A0AE8, LoadWmmt5CarData);

		// crash fix
		//safeJMP(imageBase + 0xAD6F28, WmmtOperatorDelete);
		//safeJMP(imageBase + 0xAD6F4C, WmmtMemset);

		// Save progress trigger
		injector::WriteMemory<WORD>(imageBase + 0x556CE3, 0xB848, true);
		injector::WriteMemory<uintptr_t>(imageBase + 0x556CE3 + 2, (uintptr_t)SaveOk, true);
		injector::WriteMemory<DWORD>(imageBase + 0x556CED, 0x9090D0FF, true);

		// Try save later!
		injector::MakeNOP(imageBase + 0x308546, 0x12);
		injector::WriteMemory<WORD>(imageBase + 0x308546, 0xB848, true);
		injector::WriteMemory<uintptr_t>(imageBase + 0x308546 + 2, (uintptr_t)SaveGameData, true);
		injector::WriteMemory<DWORD>(imageBase + 0x308550, 0x3348D0FF, true);
		injector::WriteMemory<WORD>(imageBase + 0x308550 + 4, 0x90C0, true);

		CreateThread(0, 0, Wmmt5FfbCollector, 0, 0, 0);
		*/
		if (!isUpdate5)
		{
			// Enable all print
			injector::MakeNOP(imageBasedxplus + 0x898BD3, 6);

			//load car trigger
			safeJMP(imageBasedxplus + 0x72AB90, loadCar);

			//save car trigger
			//injector::WriteMemory<uintptr_t>(imageBase + 0x376F80 + 2, (uintptr_t)SaveGameData, true);
			//safeJMP(imageBase + 0x376F76, SaveGameData);


			injector::MakeNOP(imageBasedxplus + 0x376F76, 0x12);
			injector::WriteMemory<WORD>(imageBasedxplus + 0x376F76, 0xB848, true);
			injector::WriteMemory<uintptr_t>(imageBasedxplus + 0x376F76 + 2, (uintptr_t)SaveGameData, true);
			injector::WriteMemory<DWORD>(imageBasedxplus + 0x376F80, 0x3348D0FF, true);
			injector::WriteMemory<WORD>(imageBasedxplus + 0x376F80 + 4, 0x90C0, true);

			//prevents startup saving
			//injector::MakeNOP(imageBase + 0x6B908C, 0x0D);
			//safeJMP(imageBase + 0x6B908C, SaveOk);
			injector::WriteMemory<WORD>(imageBasedxplus + 0x6B909A, 0xB848, true);
			injector::WriteMemory<uintptr_t>(imageBasedxplus + 0x6B909A + 2, (uintptr_t)SaveOk, true);
			injector::WriteMemory<DWORD>(imageBasedxplus + 0x6B90A4, 0x9090D0FF, true);
		}
		else
		{
			safeJMP(imageBasedxplus + 0x7786B0, loadCarUpdate5);
		}
	}

	MH_EnableHook(MH_ALL_HOOKS);

}, GameID::WMMT5DXPlus);
#endif
#pragma optimize("", on)