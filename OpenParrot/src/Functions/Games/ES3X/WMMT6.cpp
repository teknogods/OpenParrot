#include <filesystem>
#include <StdInc.h>
#include "Utility/InitFunction.h"
#include "Functions/Global.h"
#include "MinHook.h"
#include <Utility/Hooking.Patterns.h>
#include <thread>
#include <iostream>
#include <Windowsx.h>
#include "TouchEmu.h"
#include "BanapassEmu.h"
#include <iphlpapi.h>
#include <winternl.h>
#include <WinDNS.h>
#ifdef _M_AMD64
#pragma optimize("", off)
#pragma comment(lib, "Ws2_32.lib")

extern LPCSTR hookPort;
static uintptr_t imageBase;
static unsigned char hasp_buffer[0xD40];
static bool isFreePlay;
static bool isEventMode2P;
static bool isEventMode4P;
static bool ForceFullTune;
static bool ForceNeon;
static bool CarTuneNeonThread;
static const char* ipaddr;

static DWORD mileageValue = 0;
static int NeonColour;

#define HASP_STATUS_OK 0
static unsigned int Hook_hasp_login(int feature_id, void* vendor_code, int hasp_handle) {
#ifdef _DEBUG
	OutputDebugStringA("hasp_login\n");
#endif
	return HASP_STATUS_OK;
}

static unsigned int Hook_hasp_logout(int hasp_handle) {
#ifdef _DEBUG
	OutputDebugStringA("hasp_logout\n");
#endif
	return HASP_STATUS_OK;
}

static unsigned int Hook_hasp_encrypt(int hasp_handle, unsigned char* buffer, unsigned int buffer_size) {
#ifdef _DEBUG
	OutputDebugStringA("hasp_encrypt\n");
#endif
	return HASP_STATUS_OK;
}

static unsigned int Hook_hasp_decrypt(int hasp_handle, unsigned char* buffer, unsigned int buffer_size) {
#ifdef _DEBUG
	OutputDebugStringA("hasp_decrypt\n");
#endif
	return HASP_STATUS_OK;
}

static unsigned int Hook_hasp_get_size(int hasp_handle, int hasp_fileid, unsigned int* hasp_size) {
#ifdef _DEBUG
	OutputDebugStringA("hasp_get_size\n");
#endif
	* hasp_size = 0xD40; // Max addressable size by the game... absmax is 4k
	return HASP_STATUS_OK;
}

static unsigned int Hook_hasp_read(int hasp_handle, int hasp_fileid, unsigned int offset, unsigned int length, unsigned char* buffer) {
#ifdef _DEBUG
	OutputDebugStringA("hasp_read\n");
#endif
	memcpy(buffer, hasp_buffer + offset, length);
	return HASP_STATUS_OK;
}

static unsigned int Hook_hasp_write(int hasp_handle, int hasp_fileid, unsigned int offset, unsigned int length, unsigned char* buffer) {
	return HASP_STATUS_OK;
}

typedef int (WINAPI* BIND)(SOCKET, CONST SOCKADDR*, INT);
static BIND pbind = NULL;

static unsigned int WINAPI Hook_bind(SOCKET s, const sockaddr* addr, int namelen) {
	sockaddr_in bindAddr = { 0 };
	bindAddr.sin_family = AF_INET;
	bindAddr.sin_addr.s_addr = inet_addr("192.168.96.20");
	bindAddr.sin_port = htons(50765);
	if (addr == (sockaddr*)&bindAddr) {
		sockaddr_in bindAddr2 = { 0 };
		bindAddr2.sin_family = AF_INET;
		bindAddr2.sin_addr.s_addr = inet_addr(ipaddr);
		bindAddr2.sin_port = htons(50765);
		return pbind(s, (sockaddr*)&bindAddr2, namelen);
	}
	else {
		return pbind(s, addr, namelen);

	}
}

static BOOL FileExists(char* szPath)
{
	DWORD dwAttrib = GetFileAttributesA(szPath);

	return (dwAttrib != INVALID_FILE_ATTRIBUTES &&
		!(dwAttrib & FILE_ATTRIBUTE_DIRECTORY));
}

static int ReturnTrue()
{
	return 1;
}

static BYTE GenerateChecksum(unsigned char* myArray, int index, int length)
{
	BYTE crc = 0;
	for (int i = 0; i < length; i++)
	{
		crc += myArray[index + i];
	}
	return crc & 0xFF;
}

static void GenerateDongleData(bool isTerminal)
{
	memset(hasp_buffer, 0, 0xD40);
	hasp_buffer[0] = 0x01;
	hasp_buffer[0x13] = 0x01;
	hasp_buffer[0x17] = 0x0A;
	hasp_buffer[0x1B] = 0x04;
	hasp_buffer[0x1C] = 0x3B;
	hasp_buffer[0x1D] = 0x6B;
	hasp_buffer[0x1E] = 0x40;
	hasp_buffer[0x1F] = 0x87;

	hasp_buffer[0x23] = 0x01;
	hasp_buffer[0x27] = 0x0A;
	hasp_buffer[0x2B] = 0x04;
	hasp_buffer[0x2C] = 0x3B;
	hasp_buffer[0x2D] = 0x6B;
	hasp_buffer[0x2E] = 0x40;
	hasp_buffer[0x2F] = 0x87;
	if (isTerminal)
	{
		memcpy(hasp_buffer + 0xD00, "280811990002", 12); // not sure these are OK, since its from google lol.
		hasp_buffer[0xD3E] = GenerateChecksum(hasp_buffer, 0xD00, 62);
		hasp_buffer[0xD3F] = hasp_buffer[0xD3E] ^ 0xFF;
	}
	else
	{
		memcpy(hasp_buffer + 0xD00, "280813990002", 12);
		hasp_buffer[0xD3E] = GenerateChecksum(hasp_buffer, 0xD00, 62);
		hasp_buffer[0xD3F] = hasp_buffer[0xD3E] ^ 0xFF;
	}
}

static HWND mt6Hwnd;

typedef BOOL(WINAPI* ShowWindow_t)(HWND, int);
static ShowWindow_t pShowWindow;

// Hello Win32 my old friend...
typedef LRESULT(WINAPI* WindowProcedure_t)(HWND, UINT, WPARAM, LPARAM);
static WindowProcedure_t pMaxituneWndProc;

static BOOL gotWindowSize = FALSE;

static LRESULT Hook_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	if (!gotWindowSize)
	{
		mt6SetDisplayParams(hwnd);
		gotWindowSize = TRUE;
	}

	if (msg == WM_LBUTTONDOWN ||
		msg == WM_LBUTTONUP)
	{
		mt6SetTouchData(lParam, msg == WM_LBUTTONDOWN, false);
		return 0;
	}

	if (msg == WM_POINTERDOWN ||
		msg == WM_POINTERUP)
	{
		mt6SetTouchData(lParam, msg == WM_POINTERDOWN, true);
		return 0;
	}

	return pMaxituneWndProc(hwnd, msg, wParam, lParam);
}

static BOOL Hook_ShowWindow(HWND hwnd, int nCmdShow)
{
	SetWindowLongPtrW(hwnd, -4, (LONG_PTR)Hook_WndProc);
	ShowCursor(1);

	mt6Hwnd = hwnd;
	return pShowWindow(hwnd, nCmdShow);
}

typedef void (WINAPI* OutputDebugStringA_t)(LPCSTR);

static void Hook_OutputDebugStringA(LPCSTR str)
{
	printf("debug> %s", str);
}

extern int* ffbOffset;
extern int* ffbOffset2;
extern int* ffbOffset3;
extern int* ffbOffset4;


static __int64(__fastcall* g_origMileageFix)(__int64);

static __int64 __fastcall MileageFix(__int64 a1)
{
	//*(DWORD*)(a1 + 224) = mileageValue;
	//auto result = g_origMileageFix(a1);
	//mileageValue += *(DWORD*)(a1 + 228);
	return g_origMileageFix(a1);
}

DNS_STATUS(WINAPI* g_origDnsQuery_A)(PCSTR pszName, WORD wType, DWORD Options, PVOID pExtra, PDNS_RECORD* ppQueryResults, PVOID* pReserved);

DNS_STATUS WINAPI DnsQuery_AHook(PCSTR pszName, WORD wType, DWORD Options, PVOID pExtra, PDNS_RECORD* ppQueryResults, PVOID* pReserved)
{
#if _DEBUG
	info(true, "DnsQuery_AHook: %s", pszName);
#endif

	if (strncmp(pszName, "tenporouter.loc", 15) == 0 || strncmp(pszName, "bbrouter.loc", 15) == 0)
	{
		// TODO: make this configurable?
		const char* dnsName = config["Network"]["RouterIP"].c_str();

		return g_origDnsQuery_A(dnsName, wType, Options, pExtra, ppQueryResults, pReserved);
	}
	if (strncmp(pszName, "naominet.jp", 15) == 0)
	{
		const char* dnsName = "teknoparrot.xyz";

		return g_origDnsQuery_A(dnsName, wType, Options, pExtra, ppQueryResults, pReserved);
	}
	if (strncmp(pszName, "mobirouter.loc", 14) == 0 || strncmp(pszName, "dslrouter.loc", 13) == 0)
	{
#if _DEBUG
		info(true, "DnsQuery_AHooked: returning error.");
#endif
		return NULL;
	}

	return g_origDnsQuery_A(pszName, wType, Options, pExtra, ppQueryResults, pReserved);
}

DNS_STATUS(WINAPI* g_origDnsQueryEx)(PDNS_QUERY_REQUEST pQueryRequest, PDNS_QUERY_RESULT pQueryResults, PDNS_QUERY_CANCEL pCancelHandle);

DNS_STATUS WINAPI DnsQueryExHook(PDNS_QUERY_REQUEST pQueryRequest, PDNS_QUERY_RESULT pQueryResults, PDNS_QUERY_CANCEL pCancelHandle)
{
#if _DEBUG
	//info(true, "DnsQueryEx: %s", pQueryRequest->QueryName);
#endif
	if (wcsncmp(pQueryRequest->QueryName, L"mobirouter.loc", 14) == 0)
	{
		DNS_QUERY_REQUEST QueryRequest;
		QueryRequest.Version = pQueryRequest->Version;
		QueryRequest.QueryName = L"plsfail";
		QueryRequest.QueryOptions = pQueryRequest->QueryOptions;
		QueryRequest.pDnsServerList = pQueryRequest->pDnsServerList;
		QueryRequest.InterfaceIndex = pQueryRequest->InterfaceIndex;
		QueryRequest.pQueryCompletionCallback = pQueryRequest->pQueryCompletionCallback;
		QueryRequest.pQueryContext = pQueryRequest->pQueryContext;

		return g_origDnsQueryEx(&QueryRequest, pQueryResults, pCancelHandle);
	}

	if (wcsncmp(pQueryRequest->QueryName, L"tenporouter.loc", 15) == 0 || wcsncmp(pQueryRequest->QueryName, L"bbrouter.loc", 15) == 0)
	{
		// TODO: make it configurable? Add check for other common sega stuff?
		wchar_t* wString = new wchar_t[4096];
		MultiByteToWideChar(CP_ACP, 0, config["Network"]["RouterIP"].c_str(), -1, wString, 4096);
		DNS_QUERY_REQUEST QueryRequest;
		QueryRequest.Version = pQueryRequest->Version;
		QueryRequest.QueryName = wString;
		QueryRequest.QueryOptions = pQueryRequest->QueryOptions;
		QueryRequest.pDnsServerList = pQueryRequest->pDnsServerList;
		QueryRequest.InterfaceIndex = pQueryRequest->InterfaceIndex;
		QueryRequest.pQueryCompletionCallback = pQueryRequest->pQueryCompletionCallback;
		QueryRequest.pQueryContext = pQueryRequest->pQueryContext;

		return g_origDnsQueryEx(&QueryRequest, pQueryResults, pCancelHandle);
	}

	return g_origDnsQueryEx(pQueryRequest, pQueryResults, pCancelHandle);
}

int(WSAAPI* g_origInetPtonW)(INT Family, PCWSTR pszAddrString, PVOID pAddrBuf);

int WSAAPI InetPtonWHook(INT Family, PCWSTR pszAddrString, PVOID pAddrBuf)
{
#if _DEBUG
	//infoW(true, L"InetPtonWHook: %s", pszAddrString);
#endif
	// idk yet if this is also needed or not.
	//if (wcsncmp(pszAddrString, L"tenporouter.loc", 15) == 0)
	//{
	//	return g_origInetPtonW(Family, L"localhost", pAddrBuf);
	//}
	//if (wcsncmp(pszAddrString, L"mobirouter.loc", 15) == 0) 
	//{
	//	return g_origInetPtonW(Family, L"plsfail", pAddrBuf);
	//}

	return g_origInetPtonW(Family, pszAddrString, pAddrBuf);
}

int(WSAAPI* g_origgetaddrinfo)(PCSTR pNodeName, PCSTR pServiceName, const ADDRINFOA* pHints, PADDRINFOA* ppResult);

int WSAAPI getaddrinfoHook(PCSTR pNodeName, PCSTR pServiceName, const ADDRINFOA* pHints, PADDRINFOA* ppResult)
{
#if _DEBUG
	info(true, "getaddrinfo: %s, %s", pNodeName, pServiceName);
#endif

	return g_origgetaddrinfo(pNodeName, pServiceName, pHints, ppResult);
}

// array size is 1107
static const unsigned char terminal_cert_v388[] = {
  0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x42, 0x45, 0x47, 0x49, 0x4e, 0x20, 0x43, 0x45, 0x52, 0x54, 0x49,
  0x46, 0x49, 0x43, 0x41, 0x54, 0x45, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a, 0x4d, 0x49, 0x49, 0x44,
  0x42, 0x44, 0x43, 0x43, 0x41, 0x6d, 0x32, 0x67, 0x41, 0x77, 0x49, 0x42, 0x41, 0x67, 0x49, 0x55,
  0x47, 0x73, 0x75, 0x41, 0x30, 0x53, 0x50, 0x37, 0x66, 0x63, 0x45, 0x73, 0x53, 0x31, 0x4e, 0x5a,
  0x63, 0x46, 0x70, 0x4f, 0x6b, 0x30, 0x59, 0x72, 0x50, 0x7a, 0x67, 0x77, 0x44, 0x51, 0x59, 0x4a,
  0x4b, 0x6f, 0x5a, 0x49, 0x68, 0x76, 0x63, 0x4e, 0x41, 0x51, 0x45, 0x46, 0x0a, 0x42, 0x51, 0x41,
  0x77, 0x67, 0x5a, 0x49, 0x78, 0x43, 0x7a, 0x41, 0x4a, 0x42, 0x67, 0x4e, 0x56, 0x42, 0x41, 0x59,
  0x54, 0x41, 0x6b, 0x70, 0x51, 0x4d, 0x51, 0x34, 0x77, 0x44, 0x41, 0x59, 0x44, 0x56, 0x51, 0x51,
  0x49, 0x44, 0x41, 0x56, 0x55, 0x62, 0x32, 0x74, 0x35, 0x62, 0x7a, 0x45, 0x67, 0x4d, 0x42, 0x34,
  0x47, 0x41, 0x31, 0x55, 0x45, 0x43, 0x67, 0x77, 0x58, 0x54, 0x6b, 0x46, 0x4e, 0x0a, 0x51, 0x30,
  0x38, 0x67, 0x51, 0x6b, 0x46, 0x4f, 0x52, 0x45, 0x46, 0x4a, 0x49, 0x45, 0x64, 0x68, 0x62, 0x57,
  0x56, 0x7a, 0x49, 0x45, 0x6c, 0x75, 0x59, 0x79, 0x34, 0x78, 0x49, 0x6a, 0x41, 0x67, 0x42, 0x67,
  0x4e, 0x56, 0x42, 0x41, 0x73, 0x4d, 0x47, 0x55, 0x35, 0x6c, 0x64, 0x48, 0x64, 0x76, 0x63, 0x6d,
  0x73, 0x67, 0x55, 0x32, 0x56, 0x79, 0x64, 0x6d, 0x56, 0x79, 0x49, 0x45, 0x52, 0x6c, 0x0a, 0x63,
  0x47, 0x46, 0x79, 0x64, 0x47, 0x31, 0x6c, 0x62, 0x6e, 0x51, 0x78, 0x4c, 0x54, 0x41, 0x72, 0x42,
  0x67, 0x4e, 0x56, 0x42, 0x41, 0x4d, 0x4d, 0x4a, 0x45, 0x35, 0x42, 0x54, 0x55, 0x4e, 0x50, 0x49,
  0x45, 0x4a, 0x42, 0x54, 0x6b, 0x52, 0x42, 0x53, 0x53, 0x42, 0x48, 0x59, 0x57, 0x31, 0x6c, 0x63,
  0x79, 0x42, 0x4a, 0x62, 0x6d, 0x4d, 0x67, 0x4c, 0x53, 0x42, 0x4f, 0x55, 0x30, 0x51, 0x67, 0x0a,
  0x51, 0x30, 0x45, 0x67, 0x55, 0x6d, 0x39, 0x76, 0x64, 0x44, 0x41, 0x67, 0x46, 0x77, 0x30, 0x79,
  0x4d, 0x54, 0x41, 0x33, 0x4d, 0x54, 0x67, 0x78, 0x4f, 0x44, 0x55, 0x35, 0x4d, 0x54, 0x42, 0x61,
  0x47, 0x41, 0x38, 0x7a, 0x4d, 0x44, 0x41, 0x78, 0x4d, 0x44, 0x6b, 0x78, 0x4f, 0x54, 0x45, 0x34,
  0x4e, 0x54, 0x6b, 0x78, 0x4d, 0x46, 0x6f, 0x77, 0x67, 0x5a, 0x49, 0x78, 0x43, 0x7a, 0x41, 0x4a,
  0x0a, 0x42, 0x67, 0x4e, 0x56, 0x42, 0x41, 0x59, 0x54, 0x41, 0x6b, 0x70, 0x51, 0x4d, 0x51, 0x34,
  0x77, 0x44, 0x41, 0x59, 0x44, 0x56, 0x51, 0x51, 0x49, 0x44, 0x41, 0x56, 0x55, 0x62, 0x32, 0x74,
  0x35, 0x62, 0x7a, 0x45, 0x67, 0x4d, 0x42, 0x34, 0x47, 0x41, 0x31, 0x55, 0x45, 0x43, 0x67, 0x77,
  0x58, 0x54, 0x6b, 0x46, 0x4e, 0x51, 0x30, 0x38, 0x67, 0x51, 0x6b, 0x46, 0x4f, 0x52, 0x45, 0x46,
  0x4a, 0x0a, 0x49, 0x45, 0x64, 0x68, 0x62, 0x57, 0x56, 0x7a, 0x49, 0x45, 0x6c, 0x75, 0x59, 0x79,
  0x34, 0x78, 0x49, 0x6a, 0x41, 0x67, 0x42, 0x67, 0x4e, 0x56, 0x42, 0x41, 0x73, 0x4d, 0x47, 0x55,
  0x35, 0x6c, 0x64, 0x48, 0x64, 0x76, 0x63, 0x6d, 0x73, 0x67, 0x55, 0x32, 0x56, 0x79, 0x64, 0x6d,
  0x56, 0x79, 0x49, 0x45, 0x52, 0x6c, 0x63, 0x47, 0x46, 0x79, 0x64, 0x47, 0x31, 0x6c, 0x62, 0x6e,
  0x51, 0x78, 0x0a, 0x4c, 0x54, 0x41, 0x72, 0x42, 0x67, 0x4e, 0x56, 0x42, 0x41, 0x4d, 0x4d, 0x4a,
  0x45, 0x35, 0x42, 0x54, 0x55, 0x4e, 0x50, 0x49, 0x45, 0x4a, 0x42, 0x54, 0x6b, 0x52, 0x42, 0x53,
  0x53, 0x42, 0x48, 0x59, 0x57, 0x31, 0x6c, 0x63, 0x79, 0x42, 0x4a, 0x62, 0x6d, 0x4d, 0x67, 0x4c,
  0x53, 0x42, 0x4f, 0x55, 0x30, 0x51, 0x67, 0x51, 0x30, 0x45, 0x67, 0x55, 0x6d, 0x39, 0x76, 0x64,
  0x44, 0x43, 0x42, 0x0a, 0x6e, 0x7a, 0x41, 0x4e, 0x42, 0x67, 0x6b, 0x71, 0x68, 0x6b, 0x69, 0x47,
  0x39, 0x77, 0x30, 0x42, 0x41, 0x51, 0x45, 0x46, 0x41, 0x41, 0x4f, 0x42, 0x6a, 0x51, 0x41, 0x77,
  0x67, 0x59, 0x6b, 0x43, 0x67, 0x59, 0x45, 0x41, 0x33, 0x47, 0x54, 0x4f, 0x41, 0x2f, 0x4a, 0x31,
  0x62, 0x69, 0x41, 0x6e, 0x71, 0x6c, 0x79, 0x70, 0x33, 0x36, 0x43, 0x55, 0x77, 0x55, 0x35, 0x42,
  0x63, 0x64, 0x63, 0x71, 0x0a, 0x39, 0x37, 0x4d, 0x61, 0x54, 0x77, 0x37, 0x68, 0x4d, 0x55, 0x66,
  0x54, 0x71, 0x58, 0x57, 0x33, 0x32, 0x35, 0x33, 0x69, 0x71, 0x48, 0x4b, 0x33, 0x50, 0x72, 0x68,
  0x58, 0x78, 0x45, 0x78, 0x7a, 0x39, 0x4a, 0x37, 0x6e, 0x70, 0x79, 0x2b, 0x31, 0x34, 0x36, 0x76,
  0x31, 0x75, 0x38, 0x4c, 0x33, 0x4e, 0x70, 0x66, 0x41, 0x48, 0x44, 0x58, 0x37, 0x45, 0x57, 0x6c,
  0x4c, 0x48, 0x51, 0x58, 0x57, 0x0a, 0x6b, 0x4e, 0x6f, 0x49, 0x37, 0x4a, 0x6b, 0x56, 0x56, 0x59,
  0x73, 0x32, 0x35, 0x66, 0x71, 0x58, 0x4c, 0x41, 0x4b, 0x79, 0x49, 0x4a, 0x4a, 0x4f, 0x42, 0x48,
  0x52, 0x43, 0x66, 0x46, 0x4f, 0x38, 0x50, 0x46, 0x79, 0x35, 0x32, 0x51, 0x53, 0x4c, 0x5a, 0x53,
  0x70, 0x7a, 0x55, 0x63, 0x68, 0x58, 0x4b, 0x61, 0x75, 0x73, 0x79, 0x79, 0x45, 0x6b, 0x32, 0x44,
  0x78, 0x70, 0x2f, 0x78, 0x61, 0x69, 0x0a, 0x65, 0x49, 0x64, 0x69, 0x68, 0x50, 0x76, 0x37, 0x49,
  0x55, 0x50, 0x6e, 0x70, 0x64, 0x30, 0x43, 0x41, 0x77, 0x45, 0x41, 0x41, 0x61, 0x4e, 0x54, 0x4d,
  0x46, 0x45, 0x77, 0x48, 0x51, 0x59, 0x44, 0x56, 0x52, 0x30, 0x4f, 0x42, 0x42, 0x59, 0x45, 0x46,
  0x45, 0x77, 0x37, 0x67, 0x4b, 0x32, 0x4c, 0x34, 0x48, 0x2f, 0x79, 0x31, 0x52, 0x4a, 0x67, 0x35,
  0x32, 0x64, 0x33, 0x66, 0x64, 0x70, 0x62, 0x0a, 0x78, 0x6c, 0x71, 0x4a, 0x4d, 0x42, 0x38, 0x47,
  0x41, 0x31, 0x55, 0x64, 0x49, 0x77, 0x51, 0x59, 0x4d, 0x42, 0x61, 0x41, 0x46, 0x45, 0x77, 0x37,
  0x67, 0x4b, 0x32, 0x4c, 0x34, 0x48, 0x2f, 0x79, 0x31, 0x52, 0x4a, 0x67, 0x35, 0x32, 0x64, 0x33,
  0x66, 0x64, 0x70, 0x62, 0x78, 0x6c, 0x71, 0x4a, 0x4d, 0x41, 0x38, 0x47, 0x41, 0x31, 0x55, 0x64,
  0x45, 0x77, 0x51, 0x49, 0x4d, 0x41, 0x59, 0x42, 0x0a, 0x41, 0x66, 0x38, 0x43, 0x41, 0x51, 0x41,
  0x77, 0x44, 0x51, 0x59, 0x4a, 0x4b, 0x6f, 0x5a, 0x49, 0x68, 0x76, 0x63, 0x4e, 0x41, 0x51, 0x45,
  0x46, 0x42, 0x51, 0x41, 0x44, 0x67, 0x59, 0x45, 0x41, 0x58, 0x46, 0x4c, 0x73, 0x70, 0x52, 0x47,
  0x67, 0x2b, 0x53, 0x4b, 0x73, 0x6f, 0x44, 0x33, 0x72, 0x48, 0x4c, 0x68, 0x47, 0x32, 0x31, 0x2f,
  0x74, 0x31, 0x64, 0x64, 0x6b, 0x6b, 0x4e, 0x70, 0x54, 0x0a, 0x78, 0x56, 0x4d, 0x31, 0x66, 0x4b,
  0x61, 0x33, 0x6a, 0x45, 0x45, 0x35, 0x7a, 0x62, 0x6d, 0x6d, 0x4a, 0x74, 0x67, 0x4e, 0x51, 0x47,
  0x33, 0x68, 0x59, 0x41, 0x77, 0x69, 0x2f, 0x71, 0x6e, 0x77, 0x57, 0x72, 0x34, 0x39, 0x55, 0x6d,
  0x41, 0x57, 0x49, 0x68, 0x5a, 0x7a, 0x43, 0x43, 0x44, 0x51, 0x53, 0x2f, 0x62, 0x30, 0x65, 0x31,
  0x32, 0x6c, 0x5a, 0x2b, 0x6e, 0x65, 0x33, 0x32, 0x77, 0x4b, 0x0a, 0x4e, 0x45, 0x2b, 0x73, 0x35,
  0x6c, 0x31, 0x53, 0x71, 0x52, 0x41, 0x51, 0x46, 0x36, 0x4e, 0x68, 0x75, 0x4f, 0x35, 0x4d, 0x37,
  0x6d, 0x51, 0x32, 0x4a, 0x47, 0x38, 0x69, 0x6e, 0x48, 0x6e, 0x4e, 0x34, 0x59, 0x77, 0x70, 0x72,
  0x66, 0x74, 0x45, 0x6f, 0x67, 0x76, 0x52, 0x2f, 0x69, 0x7a, 0x65, 0x61, 0x6b, 0x35, 0x4d, 0x4d,
  0x7a, 0x43, 0x77, 0x36, 0x34, 0x44, 0x66, 0x44, 0x43, 0x79, 0x41, 0x0a, 0x6d, 0x72, 0x4a, 0x6f,
  0x71, 0x77, 0x75, 0x71, 0x69, 0x74, 0x34, 0x3d, 0x0a, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x45, 0x4e,
  0x44, 0x20, 0x43, 0x45, 0x52, 0x54, 0x49, 0x46, 0x49, 0x43, 0x41, 0x54, 0x45, 0x2d, 0x2d, 0x2d,
  0x2d, 0x2d, 0x0a
};

// array size is 1107
static const unsigned char v388_ca_cert[] = {
  0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x42, 0x45, 0x47, 0x49, 0x4e, 0x20, 0x43, 0x45, 0x52, 0x54, 0x49,
  0x46, 0x49, 0x43, 0x41, 0x54, 0x45, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a, 0x4d, 0x49, 0x49, 0x44,
  0x42, 0x44, 0x43, 0x43, 0x41, 0x6d, 0x32, 0x67, 0x41, 0x77, 0x49, 0x42, 0x41, 0x67, 0x49, 0x55,
  0x47, 0x73, 0x75, 0x41, 0x30, 0x53, 0x50, 0x37, 0x66, 0x63, 0x45, 0x73, 0x53, 0x31, 0x4e, 0x5a,
  0x63, 0x46, 0x70, 0x4f, 0x6b, 0x30, 0x59, 0x72, 0x50, 0x7a, 0x67, 0x77, 0x44, 0x51, 0x59, 0x4a,
  0x4b, 0x6f, 0x5a, 0x49, 0x68, 0x76, 0x63, 0x4e, 0x41, 0x51, 0x45, 0x46, 0x0a, 0x42, 0x51, 0x41,
  0x77, 0x67, 0x5a, 0x49, 0x78, 0x43, 0x7a, 0x41, 0x4a, 0x42, 0x67, 0x4e, 0x56, 0x42, 0x41, 0x59,
  0x54, 0x41, 0x6b, 0x70, 0x51, 0x4d, 0x51, 0x34, 0x77, 0x44, 0x41, 0x59, 0x44, 0x56, 0x51, 0x51,
  0x49, 0x44, 0x41, 0x56, 0x55, 0x62, 0x32, 0x74, 0x35, 0x62, 0x7a, 0x45, 0x67, 0x4d, 0x42, 0x34,
  0x47, 0x41, 0x31, 0x55, 0x45, 0x43, 0x67, 0x77, 0x58, 0x54, 0x6b, 0x46, 0x4e, 0x0a, 0x51, 0x30,
  0x38, 0x67, 0x51, 0x6b, 0x46, 0x4f, 0x52, 0x45, 0x46, 0x4a, 0x49, 0x45, 0x64, 0x68, 0x62, 0x57,
  0x56, 0x7a, 0x49, 0x45, 0x6c, 0x75, 0x59, 0x79, 0x34, 0x78, 0x49, 0x6a, 0x41, 0x67, 0x42, 0x67,
  0x4e, 0x56, 0x42, 0x41, 0x73, 0x4d, 0x47, 0x55, 0x35, 0x6c, 0x64, 0x48, 0x64, 0x76, 0x63, 0x6d,
  0x73, 0x67, 0x55, 0x32, 0x56, 0x79, 0x64, 0x6d, 0x56, 0x79, 0x49, 0x45, 0x52, 0x6c, 0x0a, 0x63,
  0x47, 0x46, 0x79, 0x64, 0x47, 0x31, 0x6c, 0x62, 0x6e, 0x51, 0x78, 0x4c, 0x54, 0x41, 0x72, 0x42,
  0x67, 0x4e, 0x56, 0x42, 0x41, 0x4d, 0x4d, 0x4a, 0x45, 0x35, 0x42, 0x54, 0x55, 0x4e, 0x50, 0x49,
  0x45, 0x4a, 0x42, 0x54, 0x6b, 0x52, 0x42, 0x53, 0x53, 0x42, 0x48, 0x59, 0x57, 0x31, 0x6c, 0x63,
  0x79, 0x42, 0x4a, 0x62, 0x6d, 0x4d, 0x67, 0x4c, 0x53, 0x42, 0x4f, 0x55, 0x30, 0x51, 0x67, 0x0a,
  0x51, 0x30, 0x45, 0x67, 0x55, 0x6d, 0x39, 0x76, 0x64, 0x44, 0x41, 0x67, 0x46, 0x77, 0x30, 0x79,
  0x4d, 0x54, 0x41, 0x33, 0x4d, 0x54, 0x67, 0x78, 0x4f, 0x44, 0x55, 0x35, 0x4d, 0x54, 0x42, 0x61,
  0x47, 0x41, 0x38, 0x7a, 0x4d, 0x44, 0x41, 0x78, 0x4d, 0x44, 0x6b, 0x78, 0x4f, 0x54, 0x45, 0x34,
  0x4e, 0x54, 0x6b, 0x78, 0x4d, 0x46, 0x6f, 0x77, 0x67, 0x5a, 0x49, 0x78, 0x43, 0x7a, 0x41, 0x4a,
  0x0a, 0x42, 0x67, 0x4e, 0x56, 0x42, 0x41, 0x59, 0x54, 0x41, 0x6b, 0x70, 0x51, 0x4d, 0x51, 0x34,
  0x77, 0x44, 0x41, 0x59, 0x44, 0x56, 0x51, 0x51, 0x49, 0x44, 0x41, 0x56, 0x55, 0x62, 0x32, 0x74,
  0x35, 0x62, 0x7a, 0x45, 0x67, 0x4d, 0x42, 0x34, 0x47, 0x41, 0x31, 0x55, 0x45, 0x43, 0x67, 0x77,
  0x58, 0x54, 0x6b, 0x46, 0x4e, 0x51, 0x30, 0x38, 0x67, 0x51, 0x6b, 0x46, 0x4f, 0x52, 0x45, 0x46,
  0x4a, 0x0a, 0x49, 0x45, 0x64, 0x68, 0x62, 0x57, 0x56, 0x7a, 0x49, 0x45, 0x6c, 0x75, 0x59, 0x79,
  0x34, 0x78, 0x49, 0x6a, 0x41, 0x67, 0x42, 0x67, 0x4e, 0x56, 0x42, 0x41, 0x73, 0x4d, 0x47, 0x55,
  0x35, 0x6c, 0x64, 0x48, 0x64, 0x76, 0x63, 0x6d, 0x73, 0x67, 0x55, 0x32, 0x56, 0x79, 0x64, 0x6d,
  0x56, 0x79, 0x49, 0x45, 0x52, 0x6c, 0x63, 0x47, 0x46, 0x79, 0x64, 0x47, 0x31, 0x6c, 0x62, 0x6e,
  0x51, 0x78, 0x0a, 0x4c, 0x54, 0x41, 0x72, 0x42, 0x67, 0x4e, 0x56, 0x42, 0x41, 0x4d, 0x4d, 0x4a,
  0x45, 0x35, 0x42, 0x54, 0x55, 0x4e, 0x50, 0x49, 0x45, 0x4a, 0x42, 0x54, 0x6b, 0x52, 0x42, 0x53,
  0x53, 0x42, 0x48, 0x59, 0x57, 0x31, 0x6c, 0x63, 0x79, 0x42, 0x4a, 0x62, 0x6d, 0x4d, 0x67, 0x4c,
  0x53, 0x42, 0x4f, 0x55, 0x30, 0x51, 0x67, 0x51, 0x30, 0x45, 0x67, 0x55, 0x6d, 0x39, 0x76, 0x64,
  0x44, 0x43, 0x42, 0x0a, 0x6e, 0x7a, 0x41, 0x4e, 0x42, 0x67, 0x6b, 0x71, 0x68, 0x6b, 0x69, 0x47,
  0x39, 0x77, 0x30, 0x42, 0x41, 0x51, 0x45, 0x46, 0x41, 0x41, 0x4f, 0x42, 0x6a, 0x51, 0x41, 0x77,
  0x67, 0x59, 0x6b, 0x43, 0x67, 0x59, 0x45, 0x41, 0x33, 0x47, 0x54, 0x4f, 0x41, 0x2f, 0x4a, 0x31,
  0x62, 0x69, 0x41, 0x6e, 0x71, 0x6c, 0x79, 0x70, 0x33, 0x36, 0x43, 0x55, 0x77, 0x55, 0x35, 0x42,
  0x63, 0x64, 0x63, 0x71, 0x0a, 0x39, 0x37, 0x4d, 0x61, 0x54, 0x77, 0x37, 0x68, 0x4d, 0x55, 0x66,
  0x54, 0x71, 0x58, 0x57, 0x33, 0x32, 0x35, 0x33, 0x69, 0x71, 0x48, 0x4b, 0x33, 0x50, 0x72, 0x68,
  0x58, 0x78, 0x45, 0x78, 0x7a, 0x39, 0x4a, 0x37, 0x6e, 0x70, 0x79, 0x2b, 0x31, 0x34, 0x36, 0x76,
  0x31, 0x75, 0x38, 0x4c, 0x33, 0x4e, 0x70, 0x66, 0x41, 0x48, 0x44, 0x58, 0x37, 0x45, 0x57, 0x6c,
  0x4c, 0x48, 0x51, 0x58, 0x57, 0x0a, 0x6b, 0x4e, 0x6f, 0x49, 0x37, 0x4a, 0x6b, 0x56, 0x56, 0x59,
  0x73, 0x32, 0x35, 0x66, 0x71, 0x58, 0x4c, 0x41, 0x4b, 0x79, 0x49, 0x4a, 0x4a, 0x4f, 0x42, 0x48,
  0x52, 0x43, 0x66, 0x46, 0x4f, 0x38, 0x50, 0x46, 0x79, 0x35, 0x32, 0x51, 0x53, 0x4c, 0x5a, 0x53,
  0x70, 0x7a, 0x55, 0x63, 0x68, 0x58, 0x4b, 0x61, 0x75, 0x73, 0x79, 0x79, 0x45, 0x6b, 0x32, 0x44,
  0x78, 0x70, 0x2f, 0x78, 0x61, 0x69, 0x0a, 0x65, 0x49, 0x64, 0x69, 0x68, 0x50, 0x76, 0x37, 0x49,
  0x55, 0x50, 0x6e, 0x70, 0x64, 0x30, 0x43, 0x41, 0x77, 0x45, 0x41, 0x41, 0x61, 0x4e, 0x54, 0x4d,
  0x46, 0x45, 0x77, 0x48, 0x51, 0x59, 0x44, 0x56, 0x52, 0x30, 0x4f, 0x42, 0x42, 0x59, 0x45, 0x46,
  0x45, 0x77, 0x37, 0x67, 0x4b, 0x32, 0x4c, 0x34, 0x48, 0x2f, 0x79, 0x31, 0x52, 0x4a, 0x67, 0x35,
  0x32, 0x64, 0x33, 0x66, 0x64, 0x70, 0x62, 0x0a, 0x78, 0x6c, 0x71, 0x4a, 0x4d, 0x42, 0x38, 0x47,
  0x41, 0x31, 0x55, 0x64, 0x49, 0x77, 0x51, 0x59, 0x4d, 0x42, 0x61, 0x41, 0x46, 0x45, 0x77, 0x37,
  0x67, 0x4b, 0x32, 0x4c, 0x34, 0x48, 0x2f, 0x79, 0x31, 0x52, 0x4a, 0x67, 0x35, 0x32, 0x64, 0x33,
  0x66, 0x64, 0x70, 0x62, 0x78, 0x6c, 0x71, 0x4a, 0x4d, 0x41, 0x38, 0x47, 0x41, 0x31, 0x55, 0x64,
  0x45, 0x77, 0x51, 0x49, 0x4d, 0x41, 0x59, 0x42, 0x0a, 0x41, 0x66, 0x38, 0x43, 0x41, 0x51, 0x41,
  0x77, 0x44, 0x51, 0x59, 0x4a, 0x4b, 0x6f, 0x5a, 0x49, 0x68, 0x76, 0x63, 0x4e, 0x41, 0x51, 0x45,
  0x46, 0x42, 0x51, 0x41, 0x44, 0x67, 0x59, 0x45, 0x41, 0x58, 0x46, 0x4c, 0x73, 0x70, 0x52, 0x47,
  0x67, 0x2b, 0x53, 0x4b, 0x73, 0x6f, 0x44, 0x33, 0x72, 0x48, 0x4c, 0x68, 0x47, 0x32, 0x31, 0x2f,
  0x74, 0x31, 0x64, 0x64, 0x6b, 0x6b, 0x4e, 0x70, 0x54, 0x0a, 0x78, 0x56, 0x4d, 0x31, 0x66, 0x4b,
  0x61, 0x33, 0x6a, 0x45, 0x45, 0x35, 0x7a, 0x62, 0x6d, 0x6d, 0x4a, 0x74, 0x67, 0x4e, 0x51, 0x47,
  0x33, 0x68, 0x59, 0x41, 0x77, 0x69, 0x2f, 0x71, 0x6e, 0x77, 0x57, 0x72, 0x34, 0x39, 0x55, 0x6d,
  0x41, 0x57, 0x49, 0x68, 0x5a, 0x7a, 0x43, 0x43, 0x44, 0x51, 0x53, 0x2f, 0x62, 0x30, 0x65, 0x31,
  0x32, 0x6c, 0x5a, 0x2b, 0x6e, 0x65, 0x33, 0x32, 0x77, 0x4b, 0x0a, 0x4e, 0x45, 0x2b, 0x73, 0x35,
  0x6c, 0x31, 0x53, 0x71, 0x52, 0x41, 0x51, 0x46, 0x36, 0x4e, 0x68, 0x75, 0x4f, 0x35, 0x4d, 0x37,
  0x6d, 0x51, 0x32, 0x4a, 0x47, 0x38, 0x69, 0x6e, 0x48, 0x6e, 0x4e, 0x34, 0x59, 0x77, 0x70, 0x72,
  0x66, 0x74, 0x45, 0x6f, 0x67, 0x76, 0x52, 0x2f, 0x69, 0x7a, 0x65, 0x61, 0x6b, 0x35, 0x4d, 0x4d,
  0x7a, 0x43, 0x77, 0x36, 0x34, 0x44, 0x66, 0x44, 0x43, 0x79, 0x41, 0x0a, 0x6d, 0x72, 0x4a, 0x6f,
  0x71, 0x77, 0x75, 0x71, 0x69, 0x74, 0x34, 0x3d, 0x0a, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x45, 0x4e,
  0x44, 0x20, 0x43, 0x45, 0x52, 0x54, 0x49, 0x46, 0x49, 0x43, 0x41, 0x54, 0x45, 0x2d, 0x2d, 0x2d,
  0x2d, 0x2d, 0x0a
};

// array size is 912
static const unsigned char terminal_key_v388[] = {
  0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x42, 0x45, 0x47, 0x49, 0x4e, 0x20, 0x50, 0x52, 0x49, 0x56, 0x41,
  0x54, 0x45, 0x20, 0x4b, 0x45, 0x59, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a, 0x4d, 0x49, 0x49, 0x43,
  0x64, 0x51, 0x49, 0x42, 0x41, 0x44, 0x41, 0x4e, 0x42, 0x67, 0x6b, 0x71, 0x68, 0x6b, 0x69, 0x47,
  0x39, 0x77, 0x30, 0x42, 0x41, 0x51, 0x45, 0x46, 0x41, 0x41, 0x53, 0x43, 0x41, 0x6c, 0x38, 0x77,
  0x67, 0x67, 0x4a, 0x62, 0x41, 0x67, 0x45, 0x41, 0x41, 0x6f, 0x47, 0x42, 0x41, 0x4e, 0x78, 0x6b,
  0x7a, 0x67, 0x50, 0x79, 0x64, 0x57, 0x34, 0x67, 0x4a, 0x36, 0x70, 0x63, 0x0a, 0x71, 0x64, 0x2b,
  0x67, 0x6c, 0x4d, 0x46, 0x4f, 0x51, 0x58, 0x48, 0x58, 0x4b, 0x76, 0x65, 0x7a, 0x47, 0x6b, 0x38,
  0x4f, 0x34, 0x54, 0x46, 0x48, 0x30, 0x36, 0x6c, 0x31, 0x74, 0x39, 0x75, 0x64, 0x34, 0x71, 0x68,
  0x79, 0x74, 0x7a, 0x36, 0x34, 0x56, 0x38, 0x52, 0x4d, 0x63, 0x2f, 0x53, 0x65, 0x35, 0x36, 0x63,
  0x76, 0x74, 0x65, 0x4f, 0x72, 0x39, 0x62, 0x76, 0x43, 0x39, 0x7a, 0x61, 0x58, 0x0a, 0x77, 0x42,
  0x77, 0x31, 0x2b, 0x78, 0x46, 0x70, 0x53, 0x78, 0x30, 0x46, 0x31, 0x70, 0x44, 0x61, 0x43, 0x4f,
  0x79, 0x5a, 0x46, 0x56, 0x57, 0x4c, 0x4e, 0x75, 0x58, 0x36, 0x6c, 0x79, 0x77, 0x43, 0x73, 0x69,
  0x43, 0x53, 0x54, 0x67, 0x52, 0x30, 0x51, 0x6e, 0x78, 0x54, 0x76, 0x44, 0x78, 0x63, 0x75, 0x64,
  0x6b, 0x45, 0x69, 0x32, 0x55, 0x71, 0x63, 0x31, 0x48, 0x49, 0x56, 0x79, 0x6d, 0x72, 0x0a, 0x72,
  0x4d, 0x73, 0x68, 0x4a, 0x4e, 0x67, 0x38, 0x61, 0x66, 0x38, 0x57, 0x6f, 0x6e, 0x69, 0x48, 0x59,
  0x6f, 0x54, 0x37, 0x2b, 0x79, 0x46, 0x44, 0x35, 0x36, 0x58, 0x64, 0x41, 0x67, 0x4d, 0x42, 0x41,
  0x41, 0x45, 0x43, 0x67, 0x59, 0x42, 0x32, 0x38, 0x53, 0x78, 0x42, 0x38, 0x78, 0x4d, 0x76, 0x47,
  0x4d, 0x6c, 0x76, 0x5a, 0x73, 0x30, 0x43, 0x39, 0x46, 0x33, 0x7a, 0x71, 0x54, 0x45, 0x6d, 0x0a,
  0x71, 0x42, 0x48, 0x33, 0x56, 0x6b, 0x43, 0x48, 0x6c, 0x43, 0x63, 0x79, 0x65, 0x6d, 0x6f, 0x66,
  0x31, 0x58, 0x6b, 0x68, 0x58, 0x43, 0x63, 0x62, 0x38, 0x37, 0x55, 0x7a, 0x63, 0x7a, 0x64, 0x69,
  0x71, 0x45, 0x51, 0x59, 0x4b, 0x37, 0x34, 0x6e, 0x65, 0x31, 0x63, 0x31, 0x68, 0x50, 0x4e, 0x38,
  0x6e, 0x71, 0x37, 0x65, 0x56, 0x71, 0x32, 0x47, 0x54, 0x42, 0x65, 0x76, 0x67, 0x41, 0x31, 0x7a,
  0x0a, 0x79, 0x38, 0x4f, 0x49, 0x31, 0x33, 0x64, 0x6c, 0x51, 0x75, 0x30, 0x6f, 0x71, 0x5a, 0x4c,
  0x41, 0x65, 0x70, 0x43, 0x6f, 0x2b, 0x78, 0x4d, 0x38, 0x6a, 0x66, 0x56, 0x66, 0x55, 0x4a, 0x6b,
  0x30, 0x35, 0x74, 0x64, 0x42, 0x76, 0x65, 0x64, 0x4e, 0x70, 0x4c, 0x58, 0x6d, 0x55, 0x6f, 0x6a,
  0x36, 0x7a, 0x4b, 0x74, 0x63, 0x45, 0x75, 0x57, 0x6d, 0x4c, 0x75, 0x55, 0x53, 0x2f, 0x31, 0x4f,
  0x45, 0x0a, 0x72, 0x59, 0x56, 0x58, 0x62, 0x71, 0x35, 0x58, 0x70, 0x4a, 0x65, 0x4d, 0x62, 0x59,
  0x4f, 0x54, 0x34, 0x51, 0x4a, 0x42, 0x41, 0x50, 0x75, 0x63, 0x59, 0x63, 0x43, 0x52, 0x39, 0x32,
  0x46, 0x45, 0x71, 0x46, 0x4e, 0x74, 0x78, 0x56, 0x78, 0x4f, 0x50, 0x79, 0x59, 0x53, 0x63, 0x53,
  0x2f, 0x7a, 0x44, 0x70, 0x6e, 0x54, 0x41, 0x6c, 0x49, 0x59, 0x38, 0x44, 0x45, 0x6b, 0x51, 0x4d,
  0x74, 0x39, 0x0a, 0x79, 0x5a, 0x39, 0x32, 0x6c, 0x79, 0x2f, 0x78, 0x66, 0x72, 0x6a, 0x42, 0x31,
  0x4e, 0x52, 0x73, 0x57, 0x6c, 0x7a, 0x79, 0x4d, 0x75, 0x69, 0x66, 0x6c, 0x2b, 0x53, 0x68, 0x5a,
  0x32, 0x30, 0x36, 0x2f, 0x63, 0x4b, 0x5a, 0x79, 0x67, 0x38, 0x4e, 0x75, 0x4c, 0x6b, 0x43, 0x51,
  0x51, 0x44, 0x67, 0x50, 0x51, 0x52, 0x4b, 0x2f, 0x34, 0x42, 0x62, 0x49, 0x42, 0x79, 0x42, 0x47,
  0x71, 0x2b, 0x72, 0x0a, 0x6e, 0x62, 0x73, 0x6a, 0x4f, 0x76, 0x2f, 0x79, 0x70, 0x48, 0x36, 0x36,
  0x49, 0x44, 0x68, 0x73, 0x2f, 0x42, 0x62, 0x62, 0x6e, 0x42, 0x55, 0x59, 0x4d, 0x59, 0x2b, 0x6b,
  0x2b, 0x7a, 0x38, 0x2f, 0x37, 0x6e, 0x34, 0x32, 0x62, 0x61, 0x74, 0x4e, 0x79, 0x47, 0x66, 0x43,
  0x4a, 0x36, 0x55, 0x56, 0x35, 0x76, 0x62, 0x52, 0x64, 0x73, 0x47, 0x7a, 0x6a, 0x73, 0x61, 0x4f,
  0x6b, 0x65, 0x44, 0x64, 0x0a, 0x64, 0x62, 0x78, 0x46, 0x41, 0x6b, 0x41, 0x65, 0x77, 0x59, 0x66,
  0x6c, 0x62, 0x54, 0x4a, 0x4c, 0x44, 0x6f, 0x52, 0x77, 0x35, 0x6b, 0x73, 0x6f, 0x74, 0x46, 0x76,
  0x64, 0x77, 0x49, 0x56, 0x62, 0x63, 0x68, 0x2b, 0x48, 0x79, 0x42, 0x5a, 0x52, 0x69, 0x4d, 0x44,
  0x62, 0x6b, 0x4f, 0x33, 0x6d, 0x73, 0x66, 0x4b, 0x53, 0x62, 0x6f, 0x47, 0x65, 0x6c, 0x36, 0x75,
  0x41, 0x31, 0x42, 0x69, 0x36, 0x0a, 0x2b, 0x70, 0x2b, 0x31, 0x47, 0x74, 0x6f, 0x45, 0x4f, 0x33,
  0x58, 0x71, 0x75, 0x5a, 0x77, 0x56, 0x36, 0x77, 0x38, 0x58, 0x32, 0x59, 0x71, 0x73, 0x65, 0x6d,
  0x58, 0x70, 0x41, 0x6b, 0x41, 0x4c, 0x39, 0x78, 0x57, 0x49, 0x6a, 0x76, 0x4f, 0x68, 0x61, 0x53,
  0x67, 0x38, 0x4e, 0x31, 0x6c, 0x53, 0x56, 0x66, 0x74, 0x4c, 0x57, 0x50, 0x57, 0x5a, 0x55, 0x2b,
  0x2b, 0x7a, 0x4c, 0x4d, 0x37, 0x31, 0x0a, 0x2b, 0x63, 0x6d, 0x61, 0x64, 0x45, 0x79, 0x6e, 0x32,
  0x74, 0x55, 0x6f, 0x58, 0x34, 0x4f, 0x7a, 0x66, 0x4a, 0x31, 0x64, 0x65, 0x43, 0x4b, 0x67, 0x35,
  0x75, 0x57, 0x71, 0x64, 0x59, 0x55, 0x59, 0x6b, 0x78, 0x64, 0x75, 0x65, 0x2b, 0x44, 0x41, 0x48,
  0x51, 0x6b, 0x35, 0x53, 0x45, 0x31, 0x77, 0x59, 0x37, 0x7a, 0x6c, 0x41, 0x6b, 0x42, 0x47, 0x37,
  0x67, 0x4e, 0x71, 0x74, 0x78, 0x35, 0x30, 0x0a, 0x38, 0x4a, 0x4d, 0x61, 0x44, 0x4b, 0x71, 0x6d,
  0x46, 0x6c, 0x62, 0x33, 0x56, 0x46, 0x42, 0x47, 0x52, 0x34, 0x58, 0x54, 0x53, 0x77, 0x70, 0x75,
  0x48, 0x31, 0x4f, 0x38, 0x66, 0x37, 0x74, 0x62, 0x5a, 0x4a, 0x76, 0x74, 0x4b, 0x5a, 0x36, 0x56,
  0x56, 0x65, 0x4b, 0x58, 0x2b, 0x2b, 0x6b, 0x41, 0x2b, 0x62, 0x70, 0x41, 0x59, 0x4b, 0x76, 0x41,
  0x58, 0x45, 0x43, 0x34, 0x38, 0x6b, 0x39, 0x77, 0x0a, 0x58, 0x6f, 0x59, 0x64, 0x57, 0x48, 0x56,
  0x79, 0x62, 0x4e, 0x68, 0x38, 0x0a, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x45, 0x4e, 0x44, 0x20, 0x50,
  0x52, 0x49, 0x56, 0x41, 0x54, 0x45, 0x20, 0x4b, 0x45, 0x59, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a
};

static void prepareCerts()
{
	//data_jp/network/certs
	FILE* file2 = fopen("./data_jp/network/certs/terminal-cert_v388.pem", "wb");
	fwrite(terminal_cert_v388, 1, sizeof(terminal_cert_v388), file2);
	fclose(file2);

	FILE* cacert = fopen("./data_jp/network/certs/v388-ca-cert.pem", "wb");
	fwrite(v388_ca_cert, 1, sizeof(v388_ca_cert), cacert);
	fclose(cacert);

	FILE* termkey = fopen("./data_jp/network/private/terminal-key_v388.pem", "wb");
	fwrite(terminal_key_v388, 1, sizeof(terminal_key_v388), termkey);
	fclose(termkey);

	return;
}


static InitFunction Wmmt6Func([]()
	{
		if (std::filesystem::exists(".\\card.ini")) {
			std::remove(".\\card.ini");
		}
		//std::string accessCode = "30764352518498791337";
		//std::string chipId = "7F5C9744F111111143262C3300040610";
		char generatedAccessCode[34] = "000000000000000000000000000000000";
		strcpy(generatedAccessCode, config["Banapass"]["AccessCode"].c_str());
		WritePrivateProfileStringA("card", "accessCode", generatedAccessCode, ".\\card.ini");
		char generatedChipId[22] = "000000000000000000000";
		strcpy(generatedChipId, config["Banapass"]["Card ID"].c_str());
		WritePrivateProfileStringA("card", "chipId", generatedChipId, ".\\card.ini");

		// folder for path redirections
		prepareCerts();
		CreateDirectoryA(".\\TP", nullptr);

		/*
		FILE* fileF = _wfopen(L".\\TP\\setting.lua.gz", L"r");
		if (fileF == NULL)
		{
			FILE* settingsF = _wfopen(L".\\TP\\setting.lua.gz", L"wb");
			fwrite(settingData, 1, sizeof(settingData), settingsF);
			fclose(settingsF);
		}
		else
		{
			fclose(fileF);
		}
		*/

		bool isTerminal = false;
		if (ToBool(config["General"]["TerminalMode"]))
		{
			isTerminal = true;
		}

		std::string networkip = config["General"]["NetworkAdapterIP"];
		if (!networkip.empty())
		{
			ipaddr = networkip.c_str();
		}

		hookPort = "COM3";
		imageBase = (uintptr_t)GetModuleHandleA(0);
		MH_Initialize();
		// Hook dongle funcs
		MH_CreateHookApi(L"hasp_windows_x64_28756.dll", "hasp_write", Hook_hasp_write, NULL);
		MH_CreateHookApi(L"hasp_windows_x64_28756.dll", "hasp_read", Hook_hasp_read, NULL);
		MH_CreateHookApi(L"hasp_windows_x64_28756.dll", "hasp_get_size", Hook_hasp_get_size, NULL);
		MH_CreateHookApi(L"hasp_windows_x64_28756.dll", "hasp_decrypt", Hook_hasp_decrypt, NULL);
		MH_CreateHookApi(L"hasp_windows_x64_28756.dll", "hasp_encrypt", Hook_hasp_encrypt, NULL);
		MH_CreateHookApi(L"hasp_windows_x64_28756.dll", "hasp_logout", Hook_hasp_logout, NULL);
		MH_CreateHookApi(L"hasp_windows_x64_28756.dll", "hasp_login", Hook_hasp_login, NULL);
		MH_CreateHookApi(L"WS2_32", "bind", Hook_bind, reinterpret_cast<LPVOID*>(&pbind));
		MH_CreateHook((void*)(imageBase + 0x35AAC0), MileageFix, (void**)&g_origMileageFix);
		MH_CreateHookApi(L"dnsapi.dll", "DnsQuery_A", DnsQuery_AHook, (void**)&g_origDnsQuery_A);
		MH_CreateHookApi(L"dnsapi.dll", "DnsQueryEx", DnsQueryExHook, (void**)&g_origDnsQueryEx);
		MH_CreateHookApi(L"ws2_32.dll", "getaddrinfo", getaddrinfoHook, (void**)&g_origgetaddrinfo);
		MH_CreateHookApi(L"ws2_32.dll", "InetPtonW", InetPtonWHook, (void**)&g_origInetPtonW);

		MH_CreateHookApi(L"kernel32", "OutputDebugStringA", Hook_OutputDebugStringA, NULL);
		// CreateFile* hooks are in the JVS FILE

		// Give me the HWND please maxitune
		MH_CreateHookApi(L"user32", "ShowWindow", Hook_ShowWindow, reinterpret_cast<LPVOID*>(&pShowWindow));
		//MH_CreateHookApi(L"kernel32", "ReadFile", Hook_ReadFile, reinterpret_cast<LPVOID*>(&pReadFile));

		// Hook the window procedure
		// (The image starts at 0x140000000)
		//MH_CreateHook((void*)(imageBase + 0xB7C030), Hook_WndProc, (void**)&pMaxituneWndProc);
		pMaxituneWndProc = (WindowProcedure_t)(imageBase + 0xB7C030);

		GenerateDongleData(isTerminal);

		// resolves a system error
		injector::WriteMemory<uint8_t>(hook::get_pattern("0F 94 C0 84 C0 0F 94 C0 84 C0 75 05 45 32 ? EB", 0x13), 0, true);

		// Skip weird camera init that stucks entire pc on certain brands. TESTED ONLY ON 05!!!!
		if (ToBool(config["General"]["WhiteScreenFix"]))
		{
			injector::WriteMemory<DWORD>(hook::get_pattern("48 8B C4 55 57 41 54 41 55 41 56 48 8D 68 A1 48 81 EC 90 00 00 00 48 C7 45 D7 FE FF FF FF 48 89 58 08 48 89 70 18 45 33 F6 4C 89 75 DF 33 C0 48 89 45 E7", 0), 0x90C3C032, true);
		}

		// Best LAN setting by doomertheboomer
		injector::WriteMemory<BYTE>(imageBase + 0xA36CAA, 0xEB, true); //content router patch
		injector::MakeNOP(imageBase + 0x690876, 2, true);

		// wtf is this?
		//injector::MakeNOP(hook::get_pattern("45 33 C0 BA 65 09 00 00 48 8D 4D B0 E8 ? ? ? ? 48 8B 08", 12), 5);

		auto location = hook::get_pattern<char>("48 83 EC 28 33 D2 B9 70 00 02 00 E8 ? ? ? ? 85 C0 79 06");
		//injector::WriteMemory<uint8_t>(location + 0x12, 0xEB, true);

		// First auth error skip
		//injector::WriteMemory<BYTE>(imageBase + 0x6A0077, 0xEB, true);

		if (isTerminal)
		{
			// I don't know what these do but they stop the game from
			// throwing a fit on the dongle error
			// so I'm leaving them in here.

			// Dongle error?
			//safeJMP(hook::get_pattern("0F B6 41 05 2C 30 3C 09 77 04 0F BE C0 C3 83 C8 FF C3"), ReturnTrue);

			// More dongle error shit?
			safeJMP(hook::get_pattern("8B 01 0F B6 40 78 C3 CC CC CC CC"), ReturnTrue);
		}
		else
		{
			// Terminal on same machine check.
			injector::MakeNOP(hook::get_pattern("74 ? 80 7B 31 00 75 ? 48 8B 43 10 80 78 31 00 75 1A 48 8B D8 48 8B 00 80 78 31 00 75 ? 48 8B D8"), 2);

			/*
			injector::WriteMemory<WORD>(imageBase + 0x6A0C87, 0x00D1, true);
			injector::WriteMemory<BYTE>(imageBase + 0x20B88A, 0x90, true);
			injector::WriteMemory<BYTE>(imageBase + 0x20B88B, 0x90, true);
			injector::WriteMemory<BYTE>(imageBase + 0x20B89B, 0x90, true);
			injector::WriteMemory<BYTE>(imageBase + 0x20B89C, 0x90, true);
			injector::WriteMemory<BYTE>(imageBase + 0x20B8A1, 0x90, true);
			injector::WriteMemory<BYTE>(imageBase + 0x20B8A2, 0x90, true);

			// spam thread
			if (ToBool(config["General"]["TerminalEmulator"]))
			{
				CreateThread(0, 0, SpamMulticast, 0, 0, 0);
			}
			*/
		}

		// path fixes
		injector::WriteMemoryRaw(imageBase + 0x12C5248, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x12C5268, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x12C5288, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x12C52A8, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x12C52C8, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x12C52E8, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x12C5308, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x12C5328, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x12C5348, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x12C5360, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x135A708, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x135A720, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x135A738, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x135A760, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x135A788, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x135A7A0, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x135A7B8, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x135A7C8, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x135A7D8, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x135A7F0, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x135A808, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x135A828, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x135A848, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x135A858, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x135A868, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x135A880, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x135A898, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x135A8B0, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x135A8C8, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x135A8E0, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x135A8F8, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x135A910, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x135A928, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x135A940, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x1362D48, "TP", 2, true); // F:/contents/
		injector::WriteMemoryRaw(imageBase + 0x13B2890, "TP/contents/", 12, true); // F:contents/
		injector::WriteMemoryRaw(imageBase + 0x13B28A0, "TP/contents/", 12, true);	// G:contents/
		injector::WriteMemoryRaw(imageBase + 0x1401030, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x1401048, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x1401E08, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x1401E20, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x1401E38, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x1401E60, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x1401E88, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x1401EA0, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x14028E0, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x1402900, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x1401DDC, "TP", 2, true); // F:
		injector::WriteMemoryRaw(imageBase + 0x13652B8, "TP", 2, true);
		injector::WriteMemoryRaw(imageBase + 0x1365AC8, "TP", 2, true);

		std::string value = config["General"]["CustomName"];
		if (!value.empty())
		{
			/*
			if (value.size() > 5)
			{
				memset(customName, 0, 256);
				strcpy(customName, value.c_str());
				CreateThread(0, 0, SpamCustomName, 0, 0, 0);
			}

			injector::WriteMemory<BYTE>(imageBase + 0x10942E8, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x10F5428, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12B3EB0, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12B75A0, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12CE688, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4BF0, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4C00, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4C10, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x10942EA, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x10F542A, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12B3EB2, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12B75A2, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12CE68A, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4BF2, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4C02, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4C12, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x10942EC, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x10F542C, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12B3EB4, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12B75A4, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12CE68C, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4BF4, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4C04, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4C14, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x10942EE, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x10F542E, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12B3EB6, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12B75A6, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12CE68E, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4BF6, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4C06, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4C16, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x10942F0, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x10F5430, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12B3EB8, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12B75A8, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12CE690, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4BF8, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4C08, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4C18, 0xFF, true);

			char NameChar;
			for (int i = 0; i < value.size(); i++) {
				NameChar = value.at(i) - 0x20;

				switch (i)
				{
				case 0x00:
					injector::WriteMemory<BYTE>(imageBase + 0x10942E8, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x10F5428, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x12B3EB0, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x12B75A0, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x12CE688, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x13C4BF0, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x13C4C00, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x13C4C10, NameChar, true);
					break;
				case 0x01:
					injector::WriteMemory<BYTE>(imageBase + 0x10942EA, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x10F542A, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x12B3EB2, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x12B75A2, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x12CE68A, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x13C4BF2, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x13C4C02, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x13C4C12, NameChar, true);
					break;
				case 0x02:
					injector::WriteMemory<BYTE>(imageBase + 0x10942EC, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x10F542C, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x12B3EB4, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x12B75A4, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x12CE68C, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x13C4BF4, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x13C4C04, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x13C4C14, NameChar, true);
					break;
				case 0x03:
					injector::WriteMemory<BYTE>(imageBase + 0x10942EE, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x10F542E, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x12B3EB6, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x12B75A6, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x12CE68E, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x13C4BF6, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x13C4C06, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x13C4C16, NameChar, true);
					break;
				case 0x04:
					injector::WriteMemory<BYTE>(imageBase + 0x10942F0, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x10F5430, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x12B3EB8, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x12B75A8, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x12CE690, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x13C4BF8, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x13C4C08, NameChar, true);
					injector::WriteMemory<BYTE>(imageBase + 0x13C4C18, NameChar, true);
					break;
				}
			}
			injector::WriteMemory<BYTE>(imageBase + 0x10942E9, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x10942EB, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x10942ED, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x10942EF, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x10942F1, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x10F5429, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x10F542B, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x10F542D, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x10F542F, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x10F5431, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12B3EB1, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12B3EB3, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12B3EB5, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12B3EB7, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12B3EB9, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12B75A1, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12B75A3, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12B75A5, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12B75A7, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12B75A9, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12CE689, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12CE68B, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12CE68D, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12CE68F, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x12CE691, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4BF1, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4BF3, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4BF5, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4BF7, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4BF9, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4C01, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4C03, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4C05, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4C07, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4C09, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4C11, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4C13, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4C15, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4C17, 0xFF, true);
			injector::WriteMemory<BYTE>(imageBase + 0x13C4C19, 0xFF, true);
			*/
		}

		ForceFullTune = (ToBool(config["Tune"]["Force Full Tune"]));
		ForceNeon = (ToBool(config["Tune"]["Force Neon"]));

		if (ForceNeon)
		{
			/*
			if (strcmp(config["Tune"]["Select Neon"].c_str(), "Green") == 0)
				NeonColour = 0x01;
			if (strcmp(config["Tune"]["Select Neon"].c_str(), "Blue") == 0)
				NeonColour = 0x02;
			if (strcmp(config["Tune"]["Select Neon"].c_str(), "Red") == 0)
				NeonColour = 0x03;
			if (strcmp(config["Tune"]["Select Neon"].c_str(), "Yellow") == 0)
				NeonColour = 0x04;
			if (strcmp(config["Tune"]["Select Neon"].c_str(), "Purple") == 0)
				NeonColour = 0x05;
			if (strcmp(config["Tune"]["Select Neon"].c_str(), "Green Pattern") == 0)
				NeonColour = 0x06;
			if (strcmp(config["Tune"]["Select Neon"].c_str(), "Blue Pattern") == 0)
				NeonColour = 0x07;
			if (strcmp(config["Tune"]["Select Neon"].c_str(), "Red Pattern") == 0)
				NeonColour = 0x08;
			if (strcmp(config["Tune"]["Select Neon"].c_str(), "Yellow Pattern") == 0)
				NeonColour = 0x09;
			if (strcmp(config["Tune"]["Select Neon"].c_str(), "Purple Pattern") == 0)
				NeonColour = 0x0A;
			*/
		}

		// Fix dongle error (can be triggered by various USB hubs, dongles
		injector::MakeNOP(imageBase + 0x8C140F, 2, true);

		//Fix crash when saving story mode and Time attack, if the error isn't handled then it doesnt crash?????
		injector::WriteMemory<uint8_t>(imageBase + 0x8A6B5F, 0xEB, true);
		injector::WriteMemory<uint8_t>(imageBase + 0x8A6AE8, 0x38EB, true);

		// Save story stuff (only 05)
		{
			/*
			// skip erasing of temp card data
			injector::WriteMemory<uint8_t>(imageBase + 0xA54F13, 0xEB, true);
			// Skip erasing of temp card
			safeJMP(imageBase + 0x647FB0, LoadGameData);
			safeJMP(imageBase + 0x65ED40, ReturnTrue);
			safeJMP(imageBase + 0x682A00, ReturnTrue);
			safeJMP(imageBase + 0x68CD40, ReturnTrue);

			safeJMP(imageBase + 0xACEA10, ReturnTrue);
			safeJMP(imageBase + 0x65F1F0, ReturnTrue);
			safeJMP(imageBase + 0x6856F0, ReturnTrue);

			// Skip more
			safeJMP(imageBase + 0x641950, ReturnTrue);
			safeJMP(imageBase + 0xACDCE0, ReturnTrue);
			safeJMP(imageBase + 0x6B7030, ReturnTrue);
			safeJMP(imageBase + 0x6C73D0, ReturnTrue);
			safeJMP(imageBase + 0xA85F20, ReturnTrue);
			safeJMP(imageBase + 0x64F600, ReturnTrue);
			safeJMP(imageBase + 0x61BD00, ReturnTrue);

			safeJMP(imageBase + 0x6C8818, LoadWmmt5CarData);

			// Save progress trigger
			injector::WriteMemory<WORD>(imageBase + 0x655154, 0xB848, true);
			injector::WriteMemory<uintptr_t>(imageBase + 0x655154 + 2, (uintptr_t)SaveOk, true);
			injector::WriteMemory<DWORD>(imageBase + 0x655154 + 0xA, 0x9090D0FF, true);

			// Try save later!
			injector::MakeNOP(imageBase + 0x399A56, 0x12);
			injector::WriteMemory<WORD>(imageBase + 0x399A56, 0xB848, true);
			injector::WriteMemory<uintptr_t>(imageBase + 0x399A56 + 2, (uintptr_t)SaveGameData, true);
			injector::WriteMemory<DWORD>(imageBase + 0x399A60, 0x3348D0FF, true);
			injector::WriteMemory<WORD>(imageBase + 0x399A60 + 4, 0x90C0, true);
			*/
		}
		//init_BanapassEmu();
		MH_EnableHook(MH_ALL_HOOKS);
	}, GameID::WMMT6);
#endif
#pragma optimize("", on)